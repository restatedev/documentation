---
sidebar_position: 3
---

# Observability

Restate bundles several observability features to inspect the behaviour of the runtime and services.

## Logging

By default, Restate logs INFO, WARN and ERROR events using a pretty format.

A complete list of configuration options is available in the [configuration documentation](./configuration).

### Log filter

You can modify the filter used for log events setting the configuration entry `observability.log.filter`, or alternatively setting the `RUST_LOG` environment variable. Check the [`RUST_LOG` documentation](https://docs.rs/tracing-subscriber/latest/tracing_subscriber/filter/struct.EnvFilter.html) for more details about the filter format. For example to enable debug logs on all restate components, and info on other logs, set the filter as `info,restate=debug`. See the paragraph below [components and log events](#components-and-log-event-context-fields) for more details about filter targets.

### Log format

You can modify the log format by setting the configuration entry `observability.log.format` as follows:

* `Pretty`: Very verbose pretty format with rendered error descriptions, when available
* `Compact`: Compact single line format
* `Json`: Newline delimited json format

### Components and log event context fields

The following components are producing relevant logs:

* `restate_ingress_grpc`: The component ingesting gRPC/Connect HTTP requests inside Restate
* `restate_meta`: The component responsible for holding the metadata informations and executing service discovery
* `restate_invoker`: The component interacting with deployed service endpoints
* `restate_worker::partition::effects`: The state machine effects
* `restate_storage`: Restate storage layer
* `hyper`: The HTTP library

Most log events generated by Restate will also have the following attached attributes:

* `rpc.service`: The related service
* `rpc.method`: The related method
* `restate.invocation.key`: The instance key of the related service
* `restate.invocation.id`: The id of the related invocation

### Recommendations

When testing Restate locally, we recommend keeping the default configuration.

When deploying in production, we recommend setting the log level to `info` and enabling the `Json` format in conjunction with a log collector, so you can later inspect and filter logs based on its event fields.

## Tracing

Restate supports the following tracing features:

* Runtime execution tracing per invocation
* Exporting traces to Jaeger
* Correlating parent traces of incoming gRPC/Connect HTTP requests, using the [W3C TraceContext](https://github.com/w3c/trace-context) specification.

### Setup Jaeger Agent exporter

To set up the Jaeger agent exporter, you need to set the configuration entry `observability.jaeger.endpoint` to the Jaeger UDP exporter `host:port`, where the port is usually [`6831`](https://www.jaegertracing.io/docs/1.6/deployment/#agent). Refer to [Jaeger documentation](https://www.jaegertracing.io/docs/1.20/deployment/) for more details on how to deploy the Jaeger agent.

You can configure a span/event filter in a similar fashion to the [Log filter](#log-filter) setting the `observability.jaeger.filter` configuration entry.

### Setup Jaeger file exporter

If you can't configure a Jaeger agent, you can still export traces writing them to files, using the Jaeger JSON format. In order to do so, setup the configuration entry `observability.jaeger_file.path` pointing towards the path where trace files should be written.

You can import the trace files using the Jaeger UI:

![Jaeger UI File import](/img/jaeger-import-file.png)

You can configure a span/event filter in a similar fashion to the [Log filter](#log-filter) setting the `observability.jaeger_file.filter` configuration entry.

### Understanding traces

Similarly to logs, traces export [attributes/tags](#components-and-log-event-context-fields) that correlates the trace with the service and/or invocation. For example, you can filter directly in the Jaeger UI all the traces belonging to the service `org.example.ExampleService` by setting the tag filter `rpc.service=org.example.ExampleService`.

Restate traces don't look like traditional HTTP server traces, because of the inner workings of Restate and OpenTelemetry/Jaeger. For each invocation, a span named `service_invocation` is created to mark the beginning of the invocation, and a child span `end_invocation` is created to mark the end of an invocation. You can easily check for every invocation if it ended or not by checking whether the span `service_invocation` has the `end_invocation` child or not.

The spans `ingress_service_invocation` informs when the gRPC/Connect HTTP request is received, and `invoker_invocation_task` informs when the runtime invokes the service endpoint to process the request.

![Jaeger trace](/img/jaeger-trace.png)

When a service invokes another service, the child invocation will be automatically linked to the span `service_invocation` of the parent invocation.

## Troubleshooting

Restate's observability features can help debug the execution of your application, to find out eventual bugs in your codebase, problems with network and/or deployment, or even Restate bugs.

In general, we reccomend to:

* Setup either Jaeger or Jaeger File trace exporter with filter `info,restate_worker::partition::effects=debug`. With this filter, the traces will also contain all the steps executed by the Restate internal state machine to drive the invocation to completion.
* Setup logging to a more verbose filter, and use the `Pretty` format. Some example filters:
    * `info,restate_ingress_grpc=trace,restate_invoker=trace,restate=debug,hyper=debug` for network related issues
    * `info,restate_worker::partition::effects=debug` to get insights on the state machine effects
    * `info,restate_meta=trace` to check service discovery and registration