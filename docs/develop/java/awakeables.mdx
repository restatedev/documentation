---
sidebar_position: 6
description: "Pause invocations while waiting for an external task completion."
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Awakeables

Awakeables pause an invocation while waiting for another process to complete a task.
You can use this pattern to let a handler execute a task somewhere else and retrieve the result.
This pattern is also known as the callback (task token) pattern.

<Tabs groupId="sdk" queryString>
    <TabItem value="java" label="Java">
        <CH.Section>
        <CH.Code>
        ```java MyHandler.java
        CODE_LOAD::java/src/main/java/develop/Awakeables.java#<start_create>-<end_create>
        ```
        ---

        ```java ExternalProcessResolve.java
        CODE_LOAD::java/src/main/java/develop/Awakeables.java#<start_resolve>-<end_resolve>
        ```

        ```java ExternalProcessReject.java
        CODE_LOAD::java/src/main/java/develop/Awakeables.java#<start_reject>-<end_reject>
        ```

        ```shell resolve_with_curl.sh
        curl localhost:8080/restate/awakeables/prom_1PePOqp/resolve -H 'content-type: application/json'
            -d '{"hello": "world"}'
        ```

        ```shell reject_with_curl.sh
        curl localhost:8080/restate/awakeables/prom_1PePOqp/reject -H 'content-type: text/plain' \
            -d 'Very bad error!'
        ```

        </CH.Code>

        1. [**Create an awakeable**](focus://1,2). This contains a [String identifier](focus://2) and a Promise/Awaitable.
        2. [**Trigger a task/process** and attach the awakeable ID](focus://4)  (e.g. over Kafka, via HTTP,...).
            For example, send an HTTP request to a service that executes the task, and attach the ID to the payload.
            You use `ctx.run` to avoid retriggering the task this on retries.
        3. [**Wait** until the other process has executed the task.](focus://6)
        4. Once the process has finished, it **completes the awakeable**. It does this by calling into Restate and supplying the ID. It either:
            - **Resolves** the awakeable
                - [Over HTTP](focus://resolve_with_curl.sh#1:2) with [its ID](focus://resolve_with_curl.sh#1[40:52]) and [an optional payload](focus://resolve_with_curl.sh#2)
                - [Via the SDK with its ID and an optional payload](focus://ExternalProcessResolve.kt#1:2)
            - **Rejects** the awakeable with its ID and a reason: failure. This will throw [a terminal error](/develop/java/error-handling) in the waiting handler.
                - [Over HTTP](focus://reject_with_curl.sh#1:2) with [its ID](focus://reject_with_curl.sh#1[40:52]) and [an optional payload](focus://reject_with_curl.sh#2)
                - [Via the SDK with its ID and an optional payload](focus://ExternalProcessReject.kt#1:2)
        5. Once the ID has been returned to the service, the **invocation resumes**.

</CH.Section>

    </TabItem>
    <TabItem value="kotlin" label="Kotlin">
        <CH.Section>
        <CH.Code>
        ```kotlin MyHandler.kt
        CODE_LOAD::kotlin/src/main/kotlin/develop/Awakeables.kt#<start_create>-<end_create>
        ```

        ---

        ```kotlin ExternalProcessResolve.kt
        CODE_LOAD::kotlin/src/main/kotlin/develop/Awakeables.kt#<start_resolve>-<end_resolve>
        ```

        ```kotlin ExternalProcessReject.kt
        CODE_LOAD::kotlin/src/main/kotlin/develop/Awakeables.kt#<start_reject>-<end_reject>
        ```

        ```shell resolve_curl.sh
        curl localhost:8080/restate/awakeables/prom_1PePOqp/resolve -H 'content-type: application/json'
            -d '{"hello": "world"}'
        ```

        ```shell reject_curl.sh
        curl localhost:8080/restate/awakeables/prom_1PePOqp/reject -H 'content-type: text/plain' \
            -d 'Very bad error!'
        ```

        </CH.Code>

        1. [**Create an awakeable**](focus://1,2). This contains a [String identifier](focus://2) and a Promise/Awaitable.
        2. [**Trigger a task/process** and attach the awakeable ID](focus://4)  (e.g. over Kafka, via HTTP,...).
        For example, send an HTTP request to a service that executes the task, and attach the ID to the payload.
        You use `ctx.run` to avoid retriggering the task this on retries.
        3. [**Wait** until the other process has executed the task.](focus://6)
        4. Once the process has finished, it **completes the awakeable**. It does this by calling into Restate and supplying the ID. It either:
            - **Resolves** the awakeable
                - [Over HTTP](focus://resolve_curl.sh#1:2) with [its ID](focus://resolve_curl.sh#1[40:52]) and [an optional payload](focus://resolve_curl.sh#2)
                - [Via the SDK with its ID and an optional payload](focus://ExternalProcessResolve.kt#1:2)
            - **Rejects** the awakeable with its ID and a reason: failure. This will throw [a terminal error](/develop/java/error-handling) in the waiting handler.
                - [Over HTTP](focus://reject_curl.sh#1:2) with [its ID](focus://reject_curl.sh#1[40:52]) and [an optional payload](focus://reject_curl.sh#2)
                - [Via the SDK with its ID and an optional payload](focus://ExternalProcessReject.kt#1:2)
        5. Once the ID has been returned to the service, the **invocation resumes**.

</CH.Section>
    </TabItem>
</Tabs>



<Tabs groupId="sdk" queryString className={"display-none"}>
<TabItem value="java" label="Java">

    <Admonition type="note" title="Specifying the serializer">
        For primitive types, you can use the Restate SDK's `CoreSerdes`.
        For other types, have a look at the [serialization docs](/develop/java/serialization).
    </Admonition>

</TabItem>
<TabItem value="kotlin" label="Kotlin">
    <Admonition type="note" title="Specifying the serializer">
        By default JSON is used to serialize payloads, using Kotlin serialization.
        For other types, have a look at the [serialization docs](/develop/java/serialization).
    </Admonition>

</TabItem>
</Tabs>

<Admonition type="tip" icon={"ðŸ’¡"} title="Cost savings on FaaS">
When running on Function-as-a-Service platforms, such as AWS Lambda, Restate suspends the handler while waiting for the awakeable to be resolved.
Since you only pay for the time that the handler is actually running, your don't pay while waiting for the external process to complete.
</Admonition>

<Admonition type="info" title="Awaiting awakeables in Virtual Objects">
    Virtual Objects only process a single invocation at a time, so the Virtual Object will be blocked while waiting on the awakeable to be resolved.
</Admonition>
