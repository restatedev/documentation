---
sidebar_position: 7
description: "Find out how you can implement workflows with the Restate SDK."
---

import Admonition from '@theme/Admonition';

# Workflows

The Workflow API let's you define workflows as a sequence of steps that gets executed durably.
A workflow can be seen as a special type of Virtual Object with some special characteristics.

In summary:

- A `run` handler that executes exactly one time for each workflow instance (object).
This is the handler which implements the workflow logic.
- Optionally, other handlers that can be called multiple times, and which interact with the workflow.
These handlers can be called up to 24 hours after the `run` handler has finished.
- Some extra SDK functionality to signal workflows via Durable Promises.

<CH.Scrollycoding>

    Have a look at the code example to get a better understanding of how workflows are implemented:

    <CH.Code lineNumbers={"true"}>
        ```java SignupWorkflow.java
        CODE_LOAD::java/src/main/java/develop/workflows/SignupWorkflow.java
        ```
    </CH.Code>

    ---

    ## Implement the `run` handler

    Every workflow needs a `run` handler.
    This handler has access to the same SDK features as Service and Virtual Object handlers.
    For example, use `ctx.run` to log intermediate resuljava in Restate and avoid re-execution on replay.

    <Admonition type="note" title={"Workflow retention time"}>
        The retention time of a workflow execution is 24 hours.
        After this timeout:
        - Any K/V state is cleared
        - The workflow's shared handlers cannot be called anymore
        - The Durable Promises are discarded

        The retention time can be configured via the [Admin API](/references/admin-api/#tag/service/operation/modify_service) per Workflow definition by setting `workflow_completion_retention`.
    </Admonition>

    <CH.Code lineNumbers={"true"}>
        ```java SignupWorkflow.java focus=9:25
        CODE_LOAD::java/src/main/java/develop/workflows/SignupWorkflow.java
        ```
    </CH.Code>

    ---

    ## Querying workflows

    You can query workflows via the other shared handlers defined in the workflow definition.
    For example, here we retrieve the status of the workflow.

    This is similar to how you would use shared handlers in a Virtual Object.

    <CH.Code lineNumbers={"true"}>
        ```java SignupWorkflow.java focus=31:34
        CODE_LOAD::java/src/main/java/develop/workflows/SignupWorkflow.java
        ```
    </CH.Code>

    ---

    ## Signaling workflows

    You can use signals to interact with your running workflows.

    You can use them to let the workflow block until an event occurs, or to send a signal / information to a running workflow.

    You can implement signals via the Durable Promises feature of the SDK.
    These promises are durable and distributed, meaning they survive crashes and can be resolved or rejected by any handler in the workflow.

    Do the following:
    1. Create a promise in your `run` handler that is durable and distributed
    2. Resolve or reject the promise in any other handler in the workflow. This can be done at most one time.

    <Admonition type={"note"} title={"Lifecycle of Restate's Durable Promises"}>
        The lifetime of the Promise is tied to the workflow execution/object and gets discarded when the retention time has passed.
        The retention time can be configured via the [Admin API](/references/admin-api/#tag/service/operation/modify_service) per workflow definition by setting `workflow_completion_retention`.
    </Admonition>

    <CH.Code lineNumbers={"true"}>
        ```java SignupWorkflow.java focus=18,26:29
        CODE_LOAD::java/src/main/java/develop/workflows/SignupWorkflow.java
        ```
    </CH.Code>

</CH.Scrollycoding>

## Submitting workflows

You can submit workflows in multiple ways:

### Via HTTP

- [By calling the `run` handler over HTTP and waiting for the response](/invoke/http#invoke-workflows):
  ```shell
  curl localhost:8080/SignupWorkflow/someone/run \
      -H 'content-type: application/json' \
      -d '{"email": "someone@restate.dev"}'
    ```

- [By calling the `run` handler over HTTP and not waiting for the response](/invoke/http#sending-a-message-over-http):
  ```shell
  curl localhost:8080/SignupWorkflow/someone/run/send \
      -H 'content-type: application/json' \
      -d '{"email": "someone@restate.dev"}'
    ```

### Via programmatic clients

- **From another Restate Service**, submit the workflow and wait for the result via:
<CH.Code>
    ```java UserManagementService.java
    CODE_LOAD::java/src/main/java/develop/workflows/UserManagementService.java
    ```
</CH.Code>

Use the `workflowSendClient` to submit the workflow and not wait for the result.

- From any other codebase:
<CH.Code>
    ```java WorkflowSubmitter.java
    CODE_LOAD::java/src/main/java/develop/workflows/WorkflowSubmitter.java#<start_submit>-<end_submit>
    ```
</CH.Code>

## Attaching to ongoing workflows

You can attach to ongoing workflows and retrieve their result later. You can either:
- Attach to a running invocation or workflow and wait for it to finish.
- Peek at the output of a running invocation or workflow. This will return:
  - `{"message":"not ready"}` for ongoing workflows
  - The result for finished workflows
  - `{"message":"not found"}` for non-existing workflows

### Via HTTP

<CH.Code>

    ```shell attach.sh
    curl localhost:8080/restate/workflow/SignupWorkflow/someone/attach
    ```

    ---

    ```shell output.sh
    curl localhost:8080/restate/workflow/SignupWorkflow/someone/output
    ```

</CH.Code>

### Via programmatic clients


<CH.Code>
    ```java WorkflowSubmitter.java
    CODE_LOAD::java/src/main/java/develop/workflows/WorkflowSubmitter.java#<start_interact>-<end_interact>
    ```
</CH.Code>


<Admonition type={"info"} title={"Inspecting workflows"}>
    Have a look at the [CLI docs](/operate/introspection) on how to inspect workflows.
</Admonition>


