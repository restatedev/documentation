---
title: "Microservice Orchestration"
sidebar_position: 2
description: "Write resilient microservices with Restate"
hide_table_of_contents: true
hide_title: true
---

import FeatureWidget from "../../src/components/FeatureWidget"
import FeatureSpotlight from "../../src/components/FeatureSpotlight"
import ExampleWidget from "../../src/components/ExampleWidget"
import FeatureList from "../../src/components/FeatureList"
import SpotlightCard from "../../src/components/SpotlightCard"
import Tabs from "@theme/Tabs"
import TabItem from "@theme/TabItem"
import {Scrollycoding} from "../../src/components/code/scrollycoding";

<Tabs groupId="sdk" queryString>
    <TabItem value="ts" label="TypeScript"/>
    <TabItem value="java" label="Java"/>
    <TabItem value="kotlin" label="Kotlin"/>
    <TabItem value="go" label="Go"/>
    <TabItem value="python" label="Python"/>
</Tabs>

<div className={"row"}>
    <div className={"col col--6 col-lg-6 col-md-12"}>
        <h1 className={"padding-top--lg text--left"}>Microservice Orchestration</h1>
        <h1 className={"use-case-subtitle text--left"}>The simplest way to build resilient applications.</h1>
        <p className={"use-case-description padding-bottom--lg text--left"}>
            Restate serves as the resilience and durability layer for distributed apps.
            Write regular functions and services, and let Restate make them resilient, consistent, and scalable.
        </p>
    </div>
    <div className={"col col--6 col-lg-6 col-md-12"}>
        <img src={"/img/use_cases/use-case-microservice-light.svg"} alt={"Microservice Orchestration"} className={"use-case-img"}/>
    </div>
</div>

<hr/>
<p className={"padding-bottom--lg"}></p>

<FeatureList className={"padding-bottom--lg"} features={[
    {
        title: 'Durable Execution',
        iconPath: '/img/code-icon.svg',
        description: "Restate ensures code runs to the end, even in the presence of failures. Failures are retried, with recovery of the progress that had been made.",
    },
    {
        title: 'Persistent K/V state',
        iconPath: '/img/use_cases/data.svg',
        description: "Persistent state directly in your objects with a simple concurrency model. State is always consistent with execution progress.",
    },
    {
        title: 'Reliable RPC',
        iconPath: '/img/use_cases/call.svg',
        description: "Restate makes communication resilient: request-response calls, async messages, webhooks, and delayed calls. User can latch onto in-flight idempotent requests.",
    },
]}/>

<p className={"padding-bottom--lg"}></p>

## Microservice Orchestration with Restate

Turn functions into durable handlers with the Restate SDK.

<Tabs groupId="sdk" className={"display-none"}>
    <TabItem value="ts" label="TypeScript">
    <Scrollycoding className="workflows-scroller">

        ### !!steps Distributed, durable building blocks
        Work with objects, functions, and promises as if failures don’t happen.
        Restate makes them distributed and durable out-of-the-box.

        ```ts ! role_updater.ts
        CODE_LOAD::ts/src/use_cases/microservices/role_updater.ts?1
        ```



        ### !!steps Scalability, concurrency, consistency

        Restate sequences requests per key, if desired.
        Scale out without fearing issues such as race conditions, multiple writers to state, etc.

        This handler updates a user’s role in set of systems.
        Other updates to the same user are queued and processed in order.
        Updates either succeed or fail, but never leave the user in an inconsistent state.

        ```ts ! role_updater.ts
        CODE_LOAD::ts/src/use_cases/microservices/role_updater.ts?2
        ```



        ### !!steps Persist progress

        Store results of interaction with external systems or non-deterministic actions.
        On retries, the action does not get re-executed but the previous result will be returned.

        ```ts ! role_updater.ts
        CODE_LOAD::ts/src/use_cases/microservices/role_updater.ts?3
        ```



        ### !!steps Sagas and rollbacks

        Implement compensation logic with Restate’s durable building blocks and Restate takes care of running it till completion.

        Here, we update the user’s role in multiple systems. If one fails, we rollback the changes in the other systems.

        ```ts ! role_updater.ts
        CODE_LOAD::ts/src/use_cases/microservices/role_updater.ts?4
        ```

    </Scrollycoding>
    </TabItem>
    <TabItem value="java" label="Java">
        <Scrollycoding className="workflows-scroller">

        ### !!steps Distributed, durable building blocks
        Work with objects, functions, and promises as if failures don’t happen.
        Restate makes them distributed and durable out-of-the-box.

        ```java ! RoleUpdateService.java
        CODE_LOAD::java/src/main/java/usecases/microservices/RoleUpdateService.java?1
        ```



        ### !!steps Scalability, concurrency, consistency

        Restate sequences requests per key, if desired.
        Scale out without fearing issues such as race conditions, multiple writers to state, etc.

        This handler updates a user’s role in set of systems.
        Other updates to the same user are queued and processed in order.
        Updates either succeed or fail, but never leave the user in an inconsistent state.

        ```java ! RoleUpdateService.java
        CODE_LOAD::java/src/main/java/usecases/microservices/RoleUpdateService.java?2
        ```



        ### !!steps Persist progress

        Store results of interaction with external systems or non-deterministic actions.
        On retries, the action does not get re-executed but the previous result will be returned.

        ```java ! RoleUpdateService.java
        CODE_LOAD::java/src/main/java/usecases/microservices/RoleUpdateService.java?3
        ```



        ### !!steps Sagas and rollbacks

        Implement compensation logic with Restate’s durable building blocks and Restate takes care of running it till completion.

        Here, we update the user’s role in multiple systems. If one fails, we rollback the changes in the other systems.

        ```java ! RoleUpdateService.java
        CODE_LOAD::java/src/main/java/usecases/microservices/RoleUpdateService.java?4
        ```

        </Scrollycoding>
    </TabItem>
    <TabItem value="kotlin" label={"Kotlin"}>
        <Scrollycoding className="workflows-scroller">

        ### !!steps Distributed, durable building blocks
        Work with objects, functions, and promises as if failures don’t happen.
        Restate makes them distributed and durable out-of-the-box.

        ```kotlin ! RoleUpdateService.kt
        CODE_LOAD::kotlin/src/main/kotlin/usecases/microservices/RoleUpdateService.kt?1
        ```



        ### !!steps Scalability, concurrency, consistency

        Restate sequences requests per key, if desired.
        Scale out without fearing issues such as race conditions, multiple writers to state, etc.

        This handler updates a user’s role in set of systems.
        Other updates to the same user are queued and processed in order.
        Updates either succeed or fail, but never leave the user in an inconsistent state.

        ```kotlin ! RoleUpdateService.kt
        CODE_LOAD::kotlin/src/main/kotlin/usecases/microservices/RoleUpdateService.kt?2
        ```



        ### !!steps Persist progress

        Store results of interaction with external systems or non-deterministic actions.
        On retries, the action does not get re-executed but the previous result will be returned.

        ```kotlin ! RoleUpdateService.kt
        CODE_LOAD::kotlin/src/main/kotlin/usecases/microservices/RoleUpdateService.kt?3
        ```



        ### !!steps Sagas and rollbacks

        Implement compensation logic with Restate’s durable building blocks and Restate takes care of running it till completion.

        Here, we update the user’s role in multiple systems. If one fails, we rollback the changes in the other systems.

        ```kotlin ! RoleUpdateService.kt
        CODE_LOAD::kotlin/src/main/kotlin/usecases/microservices/RoleUpdateService.kt?4
        ```

        </Scrollycoding>
    </TabItem>
    <TabItem value="go" label="Go">
        <Scrollycoding className="workflows-scroller">

            ### !!steps Distributed, durable building blocks
            Work with objects, functions, and promises as if failures don’t happen.
            Restate makes them distributed and durable out-of-the-box.

            ```go ! roleupdater.go
            CODE_LOAD::go/usecases/microservices/roleupdater.go?1
            ```

            ### !!steps Scalability, concurrency, consistency

            Restate sequences requests per key, if desired.
            Scale out without fearing issues such as race conditions, multiple writers to state, etc.

            This handler updates a user’s role in set of systems.
            Other updates to the same user are queued and processed in order.
            Updates either succeed or fail, but never leave the user in an inconsistent state.

            ```go ! roleupdater.go
            CODE_LOAD::go/usecases/microservices/roleupdater.go?2
            ```

            ### !!steps Persist progress

            Store results of interaction with external systems or non-deterministic actions.
            On retries, the action does not get re-executed but the previous result will be returned.

            ```go ! roleupdater.go
            CODE_LOAD::go/usecases/microservices/roleupdater.go?3
            ```

            ### !!steps Sagas and rollbacks

            Implement compensation logic with Restate’s durable building blocks and Restate takes care of running it till completion.

            Here, we update the user’s role in multiple systems. If one fails, we rollback the changes in the other systems.

            ```go ! roleupdater.go
            CODE_LOAD::go/usecases/microservices/roleupdater.go?4
            ```

        </Scrollycoding>
    </TabItem>
    <TabItem value="python" label="Python">
    <Scrollycoding className="workflows-scroller">

        ### !!steps Distributed, durable building blocks
        Work with objects, functions, and promises as if failures don’t happen.
        Restate makes them distributed and durable out-of-the-box.

        ```py ! role_updater.py
        CODE_LOAD::python/src/use_cases/microservices/role_updater.py?1
        ```

        ### !!steps Scalability, concurrency, consistency

        Restate sequences requests per key, if desired.
        Scale out without fearing issues such as race conditions, multiple writers to state, etc.

        This handler updates a user’s role in set of systems.
        Other updates to the same user are queued and processed in order.
        Updates either succeed or fail, but never leave the user in an inconsistent state.

        ```py ! role_updater.py
        CODE_LOAD::python/src/use_cases/microservices/role_updater.py?2
        ```

        ### !!steps Persist progress

        Store results of interaction with external systems or non-deterministic actions.
        On retries, the action does not get re-executed but the previous result will be returned.

        ```py ! role_updater.py
        CODE_LOAD::python/src/use_cases/microservices/role_updater.py?3
        ```

        ### !!steps Sagas and rollbacks

        Implement compensation logic with Restate’s durable building blocks and Restate takes care of running it till completion.

        Here, we update the user’s role in multiple systems. If one fails, we rollback the changes in the other systems.

        ```py ! role_updater.py
        CODE_LOAD::python/src/use_cases/microservices/role_updater.py?4
        ```

    </Scrollycoding>
</TabItem>
</Tabs>


<p className={"padding-top--lg"}>Proxy RPC calls to other services via Restate and get durability and idempotency for free.</p>

<Tabs groupId="sdk" className={"display-none"}>
<TabItem value="ts" label="TypeScript">
<Scrollycoding>

    ### !!steps Durable RPC
    Send requests to other services and Restate ensures they are delivered and processed.
    Requests can be done as request-response, as message, or delayed action.

    ```ts ! product_reservation.ts
    CODE_LOAD::ts/src/use_cases/microservices/idempotency.ts
    ```



    ### !!steps Idempotency for free

    Add an idempotency token to your request and let Restate take care of deduplication for you.
    Duplicate requests latch on to the previous one and see the same response.

    Here, we reserve a product for a user. We connect to Restate and send a `reserve` request with an idempotency key so retries wouldn't lead to double reservations.

    ```ts ! product_reservation.ts
    CODE_LOAD::ts/src/use_cases/microservices/idempotency.ts
    ```

</Scrollycoding>
</TabItem>
<TabItem value="java" label="Java">
<Scrollycoding>
    ### !!steps Durable RPC
    Send requests to other services and Restate ensures they are delivered and processed.
    Requests can be done as request-response, as message, or delayed action.

    ```java ! ProductReservation.java
    CODE_LOAD::java/src/main/java/usecases/microservices/Idempotency.java?1
    ```



    ### !!steps Idempotency for free

    Add an idempotency token to your request and let Restate take care of deduplication for you.
    Duplicate requests latch on to the previous one and see the same response.

    Here, we reserve a product for a user. We connect to Restate and send a `reserve` request with an idempotency key so retries wouldn't lead to double reservations.

    ```java ! ProductReservation.java
    CODE_LOAD::java/src/main/java/usecases/microservices/Idempotency.java?1
    ```

</Scrollycoding>
</TabItem>
<TabItem value="kotlin" label={"Kotlin"}>
<Scrollycoding>
    ### !!steps Durable RPC
    Send requests to other services and Restate ensures they are delivered and processed.
    Requests can be done as request-response, as message, or delayed action.

    ```kotlin ! ProductReservation.kt
    CODE_LOAD::kotlin/src/main/kotlin/usecases/microservices/Idempotency.kt?1
    ```



    ### !!steps Idempotency for free

    Add an idempotency token to your request and let Restate take care of deduplication for you.
    Duplicate requests latch on to the previous one and see the same response.

    Here, we reserve a product for a user. We connect to Restate and send a `reserve` request with an idempotency key so retries wouldn't lead to double reservations.

    ```kotlin ! ProductReservation.kt
    CODE_LOAD::kotlin/src/main/kotlin/usecases/microservices/Idempotency.kt?1
    ```

</Scrollycoding>
</TabItem>
<TabItem value="python" label="Python">
<Scrollycoding>

    ### !!steps Durable RPC
    Send requests to other services and Restate ensures they are delivered and processed.
    Requests can be done as request-response, as message, or delayed action.

    ```py ! product_reservation.py
    CODE_LOAD::python/src/use_cases/microservices/idempotency.py
    ```

    ### !!steps Idempotency for free

    Add an idempotency token to your request and let Restate take care of deduplication for you.
    Duplicate requests latch on to the previous one and see the same response.

    Here, we reserve a product for a user. We connect to Restate and send a `reserve` request with an idempotency key so retries wouldn't lead to double reservations.

    ```py ! product_reservation.py
    CODE_LOAD::python/src/use_cases/microservices/idempotency.py?1
    ```

</Scrollycoding>
</TabItem>
</Tabs>

<SpotlightCard>
    <FeatureSpotlight
        title={"Detailed Observability"}
        description={<p>Understand what is happening in your distributed applications, by using built-in tracing, the CLI, and the SQL engine.<br/>
        Restate tracks communication and execution, giving it a unique position for observability.</p>}
        imgPath={"/img/use_cases/tracing.svg"}
        imgSize={"100%"}
    />
</SpotlightCard>

<SpotlightCard>
    <FeatureSpotlight
        title={"Regular functions and services, in your existing infra"}
        description={<p>Your code runs just like before: as Java or NodeJS applications on FaaS, K8s, servers, containers. <br/>
            On-prem or in the cloud. Restate meets you where you are.</p>}
        imgPath={"/img/use_cases/microservice_orchestration-white.svg"}
    />
</SpotlightCard>

## What you can build with Microservice Orchestration and Restate

<ExampleWidget features={[
    {
        title: 'Idempotent async payments',
        description: "Issue an idempotent payment to Stripe and process the response. The payment provider either responds immediately or notifies us later via a webhook.",
        links: [
            {url: "https://github.com/restatedev/examples/tree/main/patterns-use-cases/async-signals-payment/async-signals-payment-java", icon: "/img/java.svg"},
            {url: "https://github.com/restatedev/examples/tree/main/patterns-use-cases/async-signals-payment/async-signals-payment-typescript", icon: "/img/typescript.svg"}
        ]
    },
    {
        title: 'Keeping systems in sync / sagas',
        description: "Reserve a flight, then a car, then handle the payment. If the payment fails, rollback the reservations.",
        links: [{url: "/guides/sagas", icon: "/img/arrow-right.svg"}]
    },
    {
        title: 'Human-in-the-loop workflows',
        description: "Food ordering: handle payment, wait till desired delivery time, ask restaurant to start preparation, wait for restaurant to confirm, deliver.",
        links: [
            {url: "https://github.com/restatedev/examples/tree/main/end-to-end-applications/java/food-ordering", icon: "/img/java.svg"},
            {url: "https://github.com/restatedev/examples/tree/main/end-to-end-applications/kotlin/food-ordering", icon: "/img/kotlin.svg"},
            {url: "https://github.com/restatedev/examples/tree/main/end-to-end-applications/typescript/food-ordering", icon: "/img/typescript.svg"}
        ]
    },
    {
        title: 'Durable state machines',
        description: "Define state transitions in your handlers and store the current state in Restate. Use single-writer per key and concurrency limits to simplify writing robust state machines.",
        links: [
            { url: "https://github.com/restatedev/examples/tree/main/patterns-use-cases/state-machines/state-machines-typescript", icon: "/img/typescript.svg"}
        ]
    },
    {
        title: 'Wondering about a specific use case?',
        description: "Let’s brainstorm together on Discord or Slack.",
        links: [
            {url: "https://discord.gg/skW3AZ6uGd", icon: "/img/discord-icon.svg"},
            {url: "https://join.slack.com/t/restatecommunity/shared_invite/zt-2v9gl005c-WBpr167o5XJZI1l7HWKImA", icon: "/img/slack.svg"}
        ]
    },
]}>
</ExampleWidget>

## Developer Resources

<FeatureWidget features={[
    {
        title: 'Blog post',
        description: <i>Why we built Restate</i>,
        link: {url: "https://restate.dev/blog/why-we-built-restate/"}
    },
    {
        title: 'Learn',
        description: (
            "Follow the Tour of Restate to learn more."
        ),
        link: {url: "/get_started/tour"}
    },
    {
        title: 'Need help?',
        description: "Join the Restate Discord or Slack communities",
        links: [
            {url: "https://discord.gg/skW3AZ6uGd", icon: "/img/discord-icon.svg"},
            {url: "https://join.slack.com/t/restatecommunity/shared_invite/zt-2v9gl005c-WBpr167o5XJZI1l7HWKImA", icon: "/img/slack.svg"}
        ]
    }
]}/>
