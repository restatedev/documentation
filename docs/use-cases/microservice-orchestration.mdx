---
title: "Microservice Orchestration"
sidebar_position: 2
description: "Write resilient microservices with Restate"
hide_table_of_contents: true
hide_title: true
---

import FeatureWidget from "../../src/components/FeatureWidget"
import FeatureSpotlight from "../../src/components/FeatureSpotlight"
import ExampleWidget from "../../src/components/ExampleWidget"
import FeatureList from "../../src/components/FeatureList"
import SpotlightCard from "../../src/components/SpotlightCard"
import Tabs from "@theme/Tabs"
import TabItem from "@theme/TabItem"

<h1 className={"padding-top--lg text--left"}>Microservice Orchestration</h1>
<h1 className={"use-case-subtitle text--left"}>The simplest way to build resilient applications.</h1>
<p className={"use-case-description padding-bottom--lg text--left"}>Regular functions and services, but now resilient, consistent, and scalable.<br/>
    Restate serves as the resilience and durability layer for distributed apps.</p>

<FeatureList className={"padding-bottom--lg"} features={[
    {
        title: 'Durable Execution',
        iconPath: '/img/code-icon.svg',
        description: "Restate ensures code runs to the end, even in the presence of failures. Failures are retried, with recovery of the progress that had been made.",
    },
    {
        title: 'Persistent K/V state',
        iconPath: '/img/use_cases/data.svg',
        description: "Persistent state directly in your objects with a simple concurrency model. State is always consistent with execution progress.",
    },
    {
        title: 'Reliable RPC',
        iconPath: '/img/use_cases/call.svg',
        description: "Restate makes communication resilient: request-response calls, async messages, webhooks, and delayed calls. User can latch onto in-flight idempotent requests.",
    },
]}/>

<p className={"padding-bottom--lg"}></p>

## Microservice Orchestration with Restate

Turn functions into durable handlers with the Restate SDK.

<Tabs groupId="sdk" queryString>
<TabItem value="ts" label="TypeScript">
<CH.Scrollycoding className="workflows-scroller">

    ### Distributed, durable building blocks
    Work with objects, functions, and promises as if failures don’t happen.
    Restate makes them distributed and durable out-of-the-box.

    ```ts role_updater.ts
    CODE_LOAD::ts/src/use_cases/microservices/role_updater.ts?1
    ```

    ---

    ### Scalability, concurrency, consistency

    Restate sequences requests per key, if desired.
    Scale out without fearing issues such as race conditions, multiple writers to state, etc.

    This handler updates a user’s role in set of systems.
    Other updates to the same user are queued and processed in order.
    Updates either succeed or fail, but never leave the user in an inconsistent state.

    ```ts role_updater.ts
    CODE_LOAD::ts/src/use_cases/microservices/role_updater.ts?2
    ```

    ---

    ### Persist progress

    Store results of interaction with external systems or non-deterministic actions.
    On retries, the action does not get re-executed but the previous result will be returned.

    ```ts role_updater.ts
    CODE_LOAD::ts/src/use_cases/microservices/role_updater.ts?3
    ```

    ---

    ### Sagas and rollbacks

    Implement compensation logic with Restate’s durable building blocks and Restate takes care of running it till completion.

    Here, we update the user’s role in multiple systems. If one fails, we rollback the changes in the other systems.

    ```ts role_updater.ts
    CODE_LOAD::ts/src/use_cases/microservices/role_updater.ts?4
    ```

</CH.Scrollycoding>
</TabItem>
<TabItem value="java" label="Java">
    <CH.Scrollycoding className="workflows-scroller">

    ### Distributed, durable building blocks
    Work with objects, functions, and promises as if failures don’t happen.
    Restate makes them distributed and durable out-of-the-box.

    ```java RoleUpdateService.java
    CODE_LOAD::java/src/main/java/usecases/microservices/RoleUpdateService.java?1
    ```

    ---

    ### Scalability, concurrency, consistency

    Restate sequences requests per key, if desired.
    Scale out without fearing issues such as race conditions, multiple writers to state, etc.

    This handler updates a user’s role in set of systems.
    Other updates to the same user are queued and processed in order.
    Updates either succeed or fail, but never leave the user in an inconsistent state.

    ```java RoleUpdateService.java
    CODE_LOAD::java/src/main/java/usecases/microservices/RoleUpdateService.java?2
    ```

    ---

    ### Persist progress

    Store results of interaction with external systems or non-deterministic actions.
    On retries, the action does not get re-executed but the previous result will be returned.

    ```java RoleUpdateService.java
    CODE_LOAD::java/src/main/java/usecases/microservices/RoleUpdateService.java?3
    ```

    ---

    ### Sagas and rollbacks

    Implement compensation logic with Restate’s durable building blocks and Restate takes care of running it till completion.

    Here, we update the user’s role in multiple systems. If one fails, we rollback the changes in the other systems.

    ```java RoleUpdateService.java
    CODE_LOAD::java/src/main/java/usecases/microservices/RoleUpdateService.java?4
    ```

    </CH.Scrollycoding>
</TabItem>
<TabItem value="kotlin" label={"Kotlin"}>
    <CH.Scrollycoding className="workflows-scroller">

    ### Distributed, durable building blocks
    Work with objects, functions, and promises as if failures don’t happen.
    Restate makes them distributed and durable out-of-the-box.

    ```kotlin RoleUpdateService.kt
    CODE_LOAD::kotlin/src/main/kotlin/use_cases/microservices/RoleUpdateService.kt?1
    ```

    ---

    ### Scalability, concurrency, consistency

    Restate sequences requests per key, if desired.
    Scale out without fearing issues such as race conditions, multiple writers to state, etc.

    This handler updates a user’s role in set of systems.
    Other updates to the same user are queued and processed in order.
    Updates either succeed or fail, but never leave the user in an inconsistent state.

    ```kotlin RoleUpdateService.kt
    CODE_LOAD::kotlin/src/main/kotlin/use_cases/microservices/RoleUpdateService.kt?2
    ```

    ---

    ### Persist progress

    Store results of interaction with external systems or non-deterministic actions.
    On retries, the action does not get re-executed but the previous result will be returned.

    ```kotlin RoleUpdateService.kt
    CODE_LOAD::kotlin/src/main/kotlin/use_cases/microservices/RoleUpdateService.kt?3
    ```

    ---

    ### Sagas and rollbacks

    Implement compensation logic with Restate’s durable building blocks and Restate takes care of running it till completion.

    Here, we update the user’s role in multiple systems. If one fails, we rollback the changes in the other systems.

    ```kotlin RoleUpdateService.kt
    CODE_LOAD::kotlin/src/main/kotlin/use_cases/microservices/RoleUpdateService.kt?4
    ```

    </CH.Scrollycoding>
</TabItem>
</Tabs>


<p className={"padding-top--lg"}>Proxy RPC calls to other services via Restate and get durability and idempotency for free.</p>

<Tabs groupId="sdk" queryString>
<TabItem value="ts" label="TypeScript">
<CH.Scrollycoding>

    ### Durable RPC
    Send requests to other services and Restate ensures they are delivered and processed.
    Requests can be done as request-response, as message, or delayed action.

    ```ts product_reservation.ts
    CODE_LOAD::ts/src/use_cases/microservices/idempotency.ts
    ```

    ---

    ### Idempotency for free

    Add an idempotency token to your request and let Restate take care of deduplication for you.
    Duplicate requests latch on to the previous one and see the same response.

    Here, we reserve a product for a user. We connect to Restate and send a `reserve` request with an idempotency key so retries wouldn't lead to double reservations.

    ```ts product_reservation.ts
    CODE_LOAD::ts/src/use_cases/microservices/idempotency.ts
    ```

</CH.Scrollycoding>
</TabItem>
<TabItem value="java" label="Java">
<CH.Scrollycoding>
    ### Durable RPC
    Send requests to other services and Restate ensures they are delivered and processed.
    Requests can be done as request-response, as message, or delayed action.

    ```java ProductReservation.java
    CODE_LOAD::java/src/main/java/usecases/microservices/Idempotency.java?1
    ```

    ---

    ### Idempotency for free

    Add an idempotency token to your request and let Restate take care of deduplication for you.
    Duplicate requests latch on to the previous one and see the same response.

    Here, we reserve a product for a user. We connect to Restate and send a `reserve` request with an idempotency key so retries wouldn't lead to double reservations.

    ```java ProductReservation.java
    CODE_LOAD::java/src/main/java/usecases/microservices/Idempotency.java?1
    ```

</CH.Scrollycoding>
</TabItem>
<TabItem value="kotlin" label={"Kotlin"}>
<CH.Scrollycoding>
    ### Durable RPC
    Send requests to other services and Restate ensures they are delivered and processed.
    Requests can be done as request-response, as message, or delayed action.

    ```kotlin ProductReservation.kt
    CODE_LOAD::kotlin/src/main/kotlin/use_cases/microservices/Idempotency.kt?1
    ```

    ---

    ### Idempotency for free

    Add an idempotency token to your request and let Restate take care of deduplication for you.
    Duplicate requests latch on to the previous one and see the same response.

    Here, we reserve a product for a user. We connect to Restate and send a `reserve` request with an idempotency key so retries wouldn't lead to double reservations.

    ```kotlin ProductReservation.kt
    CODE_LOAD::kotlin/src/main/kotlin/use_cases/microservices/Idempotency.kt?1
    ```

</CH.Scrollycoding>
</TabItem>
</Tabs>

<SpotlightCard>
    <FeatureSpotlight
        title={"Detailed Observability"}
        description={<p>Understand what is happening in your distributed applications, by using built-in tracing, the CLI, and the SQL engine.<br/>
        Restate tracks communication and execution, giving it a unique position for observability.</p>}
        imgPath={"/img/use_cases/tracing.svg"}
        imgSize={"100%"}
    />
</SpotlightCard>

<SpotlightCard>
    <FeatureSpotlight
        title={"Regular functions and services, in your existing infra"}
        description={<p>Your code runs just like before: as Java or NodeJS applications on FaaS, K8s, servers, containers. <br/>
            On-prem or in the cloud. Restate meets you where you are.</p>}
        imgPath={"/img/use_cases/microservice_orchestration-white.svg"}
    />
</SpotlightCard>

## What you can build with Microservice Orchestration and Restate

<ExampleWidget features={[
    {
        title: 'Idempotent async payments',
        description: "Issue an idempotent payment to Stripe and process the response. The payment provider either responds immediately or notifies us later via a webhook.",
        ts: "https://github.com/restatedev/examples/tree/main/patterns-use-cases/async-signals-payment/async-signals-payment-typescript",
        java: "https://github.com/restatedev/examples/tree/main/patterns-use-cases/async-signals-payment/async-signals-payment-java"
    },
    {
        title: 'Keeping systems in sync / sagas',
        description: "Reserve a flight, then a car, then handle the payment. If the payment fails, rollback the reservations.",
        ts: "https://github.com/restatedev/examples/tree/main/patterns-use-cases/sagas/sagas-typescript",
        java: "https://github.com/restatedev/examples/tree/main/patterns-use-cases/sagas/sagas-java",
        kotlin: "https://github.com/restatedev/examples/tree/main/patterns-use-cases/sagas/sagas-kotlin"
    },
    {
        title: 'Human-in-the-loop workflows',
        description: "Food ordering: handle payment, wait till desired delivery time, ask restaurant to start preparation, wait for restaurant to confirm, deliver.",
        java: "https://github.com/restatedev/examples/tree/main/end-to-end-applications/java/food-ordering",
        kotlin: "https://github.com/restatedev/examples/tree/main/end-to-end-applications/kotlin/food-ordering",
        ts: "https://github.com/restatedev/examples/tree/main/end-to-end-applications/typescript/food-ordering"
    },
    {
        title: 'Durable state machines',
        description: "Define state transitions in your handlers and store the current state in Restate. Use single-writer per key and concurrency limits to simplify writing robust state machines.",
        ts: "https://github.com/restatedev/examples/tree/main/patterns-use-cases/state-machines/state-machines-typescript"
    },
    {
        title: 'Wondering about a specific use case?',
        description: "Let’s brainstorm together on Discord",
        link: {url: "https://discord.gg/skW3AZ6uGd", icon: "/img/discord-icon.svg"}
    },
]}>
</ExampleWidget>

## Developer Resources

<FeatureWidget features={[
    {
        title: 'Blog post',
        description: <i>Why we built Restate</i>,
        link: {url: "https://restate.dev/blog/why-we-built-restate/"}
    },
    {
        title: 'Learn',
        description: (
            "Follow the Tour of Restate to learn more."
        ),
        ts: "/get_started/tour?sdk=ts",
        java: "/get_started/tour?sdk=java"
    },
    {
        title: 'Need help?',
        description: "Join the Restate Discord channel",
        link: {url: "https://discord.gg/skW3AZ6uGd", icon: "/img/discord-icon.svg"}
    }
]}/>