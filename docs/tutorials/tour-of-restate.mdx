---
sidebar_position: 1
description: "Discover and learn Restate's key features."
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# A Tour of Restate

This tutorial guides you through the development of an end-to-end Restate application,
and covers all the essential features.
After this tutorial, you should have a firm understanding of how Restate can help you
and feel comfortable to tackle your next application on your own.

This tutorial implements a ticket reservation application for a theatre.
It allows users to add tickets for specific seats to their shopping cart.
After a ticket is added, the seat gets reserved for 15 minutes.
If it hasn't been bought and paid within that time interval, the reservation is released
and the ticket becomes available to other users.

The application has three services, each with a set of methods that are implemented in this tutorial:
1. **User session service**: keeps track of the tickets in the shopping cart. Implements:
    - AddTicket: adds a ticket to the shopping cart
    - Checkout: calls the checkout service to process the payment
    - ExpireTicket: sets tickets back to available, if the user did not buy them
2. **Ticket service**: manages the tickets. Implements:
    - Reserve: sets the status of a ticket to reserved
    - Unreserve: sets the status of a ticket to available
    - MarkAsSold: sets the status of a ticket to sold
3. **Checkout service**: handles the checkout process of the ticket sale. Implements:
    - Checkout: handles the checkout process

As we go, you will discover how Restate can help you with some intricacies in this application.

## Prerequisites
> &#x1F4DD; As long as Restate hasn't been launched publicly, you need to have access to the private Restate npm packages and Docker container. Please follow the instructions in the `restate-dist` Readme to set up access: https://github.com/restatedev/restate-dist

- [NodeJS (and npm)](https://nodejs.org) installed.
- [Docker Engine](https://docs.docker.com/engine/install/) or [Podman](https://podman.io/docs/installation) to launch the Restate runtime (not needed for the app implementation itself).
- [curl](https://everything.curl.dev/get)

## üöÄ Let's get started!

### Setting up the tutorial
Clone the GitHub repository of the [tutorial](https://github.com/restatedev/tour-of-restate-typescript):
```shell
git clone git@github.com:restatedev/tour-of-restate-typescript.git
```

This GitHub repository contains the basic skeleton of the NodeJS/Typescript services that we develop in this tutorial. 

First, get all dependencies and build tools:
```shell
npm install
```

Next, generates the Typescript Protobuf code to help you write services according to your service contract.
```shell
npm run proto
```

Build the services:
```shell
npm run build
```

### Running the services and runtime
Run the services:
```shell
npm run app
```

Launch the runtime:
<Tabs groupId="operating-systems">
<TabItem value="lin" label="Linux">

```shell
docker run -e RUST_LOG=info,restate=info --network=host ghcr.io/restatedev/restate-dist:latest
```

</TabItem>
<TabItem value="mac" label="macOS">

```shell
docker run -e RUST_LOG=info,restate=info ghcr.io/restatedev/restate-dist:latest
```

</TabItem>
</Tabs>

Discover the services:
<Tabs groupId="operating-systems">
<TabItem value="lin" label="Linux">

```shell
curl -X POST http://localhost:8081/services/discover -H 'content-type: application/json' -d '{"uri": "http://localhost:8080"}'
```

</TabItem>
<TabItem value="mac" label="macOS">

```shell
curl -X POST http://localhost:8081/services/discover -H 'content-type: application/json' -d '{"uri": "http://host.docker.internal:8080"}'
```

</TabItem>
</Tabs>

You should now see the registered services printed out to your terminal:
```shell
{"services":["example.TicketService","example.UserSessionService","example.CheckoutService"]}
```

<details><summary>Show the runtime logs</summary>
When we look at the logs of the runtime we see:

```
2023-05-19T12:55:42.564152Z INFO restate_meta::service
   Discovered service
      rpc.service: "example.TicketService"
      restate.service_endpoint.url: http://localhost:8080/
2023-05-19T12:55:42.564172Z INFO restate_meta::service
   Discovered service
      rpc.service: "example.UserSessionService"
      restate.service_endpoint.url: http://localhost:8080/
2023-05-19T12:55:42.564178Z INFO restate_meta::service
   Discovered service
      rpc.service: "example.CheckoutService"
      restate.service_endpoint.url: http://localhost:8080/
```

</details>


### Calling the services

Mimic adding a ticket to a cart, by calling `UserSessionService/AddTicket` as follows:
```shell
curl -X POST http://localhost:9090/example.UserSessionService/AddTicket -H 'content-type: application/json' -d '{"user_id": "123", "ticket_id": "456"}'
```
If this prints out `true`, then you have a working setup!

You can call the `UserSessionService/Checkout` method to proceed with the purchase, as follows:

```shell
curl -X POST http://localhost:9090/example.UserSessionService/Checkout -H 'content-type: application/json' -d '{"user_id": "123"}'
```

In `src/app`, you find the skeletons of the services where you can start implementing your app.
You can also find `app.ts` there which contains the definition of the Restate server that will serve the methods.


## Services and concurrency
There are three types of Restate services:
1. **Keyed service**: All service invocations are sharded on a user-defined key. There is at most one concurrent
invocation per key.
2. **Unkeyed service**: No key defined. No concurrency guarantees or limitations. Invocations are processed as they
come in. You would get the same behavior with a keyed service with random keys.
3. **Singleton service**: No key defined. There is at most one concurrent invocation for this entire service. You can
see this as a keyed service where all invocations have an identical key. This service type does not scale up, so
don't use it for heavy load.

### Specifying the service type
Restate uses [gRPC](https://grpc.io/) and [Protobuf](https://protobuf.dev/) to define service contracts.
That's also where you define the service type and key.
Have a look at the Protobuf definitions of the ticket service of our example in `proto/example.proto`:
```protobuf
service TicketService {
  //highlight-next-line
	option (dev.restate.ext.service_type) = KEYED;

	rpc Reserve (Ticket) returns (google.protobuf.BoolValue);
    //... other methods...
}

message Ticket {
  //highlight-next-line
	string ticket_id = 1 [(dev.restate.ext.field) = KEY];
}
```

The first highlighted line of the service definition defines the type of Restate service.
The ticket service is a keyed service. For unkeyed or singleton services, use `UNKEYED` and `SINGLETON` respectively.

For keyed services, you need to tag one of the fields of the input request as the key, as done the second highlighted line.
You specify the key by adding the `[(dev.restate.ext.field) = KEY]` annotation.
Make sure that you define the key field for all the methods of a keyed service.

Besides these tags, there is nothing Restate-specific about the Protobuf definitions.
To learn more about gRPC, have a look at their [documentation](https://grpc.io/docs/).

:::tip
The concurrency guarantees of keyed (and singleton services) makes
it a lot easier to reason about interaction with external systems.

If you have a keyed service that is the single writer to a database
and every key only interacts with an isolated set of database rows.
Then you can scale your application and never have concurrent invocations
writing to the same database row. This resolves common data consistency issues such as lost updates or non-repeatable reads.

Have a look at the product service of the [shopping cart example](https://github.com/restatedev/example-shopping-cart-typescript). It's keyed on product ID,
just like the database table behind it. Restate ensures that there are never concurrent writes to the same row.
:::

:::caution
Take into account the concurrency limitations when designing your applications!
- Time-consuming operations in a keyed/singleton service (e.g.
sleep) lock that key/service for the entire operation. Other
invocations for that key/service are enqueued, until the invocation has completed.
- Deadlocks: Watch out for cyclical synchronous calls in your application.
For example, if A calls B, and B calls C, and C calls A again.
Each service waits on the response of the other and none of them can progress.
The keys remain locked and the system can't process any more requests.
:::

## Suspendable synchronous communication
:::note Implement it yourself or follow along by looking at the code under `src/part1`.
:::
One of the key parts of distributed applications is service-to-service communication.
Restate makes sure that service-to-service communication is durable.
Messages never get lost.

Let's begin with synchronous calls, in which one service calls another service and waits for the response.

When the `addTicket` method is called, it first needs to reserve the ticket for the user. It does that by calling the `TicketService/Reserve` method.
Add the highlighted code snippet to the `addTicket` method in the user session service.

```typescript
import * as restate from "@restatedev/restate-sdk";

async addTicket(request: ReserveTicket): Promise<BoolValue> {
    //highlight-start
    const ctx = restate.useContext(this);
    const ticketServiceClient = new TicketServiceClientImpl(ctx);
    const success = await ticketServiceClient.reserve(
        Ticket.create({ ticketId: request.ticketId })
    );
    //highlight-end

    return success;
}
```

To interact with Restate, we need to retrieve the `RestateContext`. This is the entrypoint of all communication with the runtime.
Afterwards, we use the client that was generated by `proto-ts` and supply the RestateContext of the current invocation (`ctx`) to the client to make sure that it uses the SDK to send the requests.
Then we call the reserve method, which returns a Promise that gets resolved with the BoolValue response.

Try it out by running the services via `npm run app` and send a request to `UserSessionService/AddTicket`, as we did [previously](#running-the-services-and-runtime).

Have a look at the SDK and runtime logs, to see how the ingress request triggers the execution of the `addTicket` and `reserve` methods.

<details><summary>Show the logs</summary>

```log
[restate] [2023-05-17T18:53:40.856Z] [UserSessionService] [AddTicket] [01882b0f-9270-7ed5-ae40-7053890a3cd2] : Received input message.
[restate] [2023-05-17T18:53:40.857Z] [UserSessionService] [AddTicket] [01882b0f-9270-7ed5-ae40-7053890a3cd2] : Adding message to output buffer: type: Invoke
[restate] [2023-05-17T18:53:40.859Z] [TicketService] [Reserve] [01882b0f-927a-7795-9416-09d03065ba8d] : Received input message.
[restate] [2023-05-17T18:53:40.860Z] [TicketService] [Reserve] [01882b0f-927a-7795-9416-09d03065ba8d] : Call ended successful with output message.
[restate] [2023-05-17T18:53:40.902Z] [UserSessionService] [AddTicket] [01882b0f-9270-7ed5-ae40-7053890a3cd2] : Received new completion from the runtime.
[restate] [2023-05-17T18:53:40.902Z] [UserSessionService] [AddTicket] [01882b0f-9270-7ed5-ae40-7053890a3cd2] : Call ended successful with output message.
```

</details>

For this tutorial, we put the log level to debug by setting the environment variable `RESTATE_DEBUG_LOG=LOG`.
You can remove this environment variable in `package.json` to silence the logging.
To also log the messages, use `RESTATE_DEBUG_LOG=MESSAGES`.

### What actually happened?
The call we just did, seems like a regular RPC call.
But under-the-hood, Restate does a number of things to make sure that this call is durable.

The runtime persists the incoming request, establishes a connection to the user session service,
and sends the request over that connection.
All the communication between the runtime and the service, will go over this connection.
The service itself never needs to set up the connection.

The service then executes the method. When it calls the ticket service,
this request goes over the open connection to the runtime, that again durably logs it and invokes the ticket service.
The runtime takes care of request retries, in case of failures (covered later on in [Resiliency](#resiliency)).
Finally, the runtime delivers the response to the user session service.

When services need to wait a long time (e.g. sleep an hour, or wait for a day on a response),
Restate makes method invocations suspend to free up the resources for other invocations.
When the service is able to resume, Restate invokes the service again and sends over a replay log.
The replay log contains the steps that the service already executed before it suspended.
The service replays the log and continues processing at the point where it left off.

:::tip
The suspension mechanism of Restate is especially beneficial if you run on serverless infrastructure (e.g. AWS Lambda).
For example, you can do synchronous calls without paying for the idle time when waiting for a response.
:::

To show this working in practice, let's mimic that the ticket service is processing
for an amount of time by adding a sleep call to the `TicketService/Reserve` method:
```typescript
async reserve(request: Ticket): Promise<BoolValue> {
    //bad-code-start
    await setTimeout(5000);
    //bad-code-end
    return BoolValue.create({value: true});
}
```
Also add the import: `import { setTimeout} from "timers/promises";`.

:::caution
This is not the proper way to sleep in a Restate application!
The Restate SDK offers you a way to do sleeps that are suspendable, as covered [later on](#suspendable-sleep).
:::

Call `UserSession/AddTicket` again and have a look at the SDK logs. Now that the the ticket service responds later, we see that the `addTicket` method suspends.
Once the runtime has received the response, it invokes the `addTicket` method again and the call finishes.

<details><summary>Show the logs</summary>

```log
[restate] [2023-05-17T19:20:50.382Z] [UserSessionService] [AddTicket] [01882b28-6fc3-7f6e-8cd1-c4dfe5983e21] : Received input message.
[restate] [2023-05-17T19:20:50.385Z] [UserSessionService] [AddTicket] [01882b28-6fc3-7f6e-8cd1-c4dfe5983e21] : Adding message to output buffer: type: Invoke
[restate] [2023-05-17T19:20:50.389Z] [TicketService] [Reserve] [01882b28-6fd3-7091-b92b-b392071925c3] : Received input message.
//highlight-next-line
[restate] [2023-05-17T19:20:51.389Z] [UserSessionService] [AddTicket] [01882b28-6fc3-7f6e-8cd1-c4dfe5983e21] : Call suspending.
[restate] [2023-05-17T19:20:55.394Z] [TicketService] [Reserve] [01882b28-6fd3-7091-b92b-b392071925c3] : Call ended successful with output message.
//highlight-next-line
[restate] [2023-05-17T19:20:55.397Z] [UserSessionService] [AddTicket] [01882b28-6fc3-7f6e-8cd1-c4dfe5983e21] : Received input message.
[restate] [2023-05-17T19:20:55.398Z] [UserSessionService] [AddTicket] [01882b28-6fc3-7f6e-8cd1-c4dfe5983e21] : Call ended successful with output message.
```

</details>


[//]: # (TODO include a video demo of knative on minikube to show how containers are spun up and torn down.)

### üìù Try it out
Make `checkout` method in the user session service call the `checkout` method in the checkout service.

For the `tickets` field in the `CheckoutFlowRequest`, you can use a hardcoded array of strings for now: `["456"]`.
We will fix this later on.

<>
<details><summary>Solution</summary>

```typescript
async checkout(request: CheckoutRequest): Promise<BoolValue> {
    const ctx = restate.useContext(this);

    //highlight-start
    const checkoutClient = new CheckoutServiceClientImpl(ctx);
    const request = CheckoutFlowRequest.create({
        userId: request.userId,
        tickets: ["465"],
    });

    const success = await checkoutClient.checkout(request);
    //highlight-end

    return BoolValue.create({ value: true });
}
```

Have a look at the logs again to see what happened:
```log
[restate] [2023-05-17T19:46:48.805Z] [UserSessionService] [Checkout] [01882b40-3760-70c8-a2bc-7e0d889c11fb] : Received input message.
[restate] [2023-05-17T19:46:48.806Z] [UserSessionService] [Checkout] [01882b40-3760-70c8-a2bc-7e0d889c11fb] : Adding message to output buffer: type: Invoke
[restate] [2023-05-17T19:46:48.808Z] [CheckoutService] [Checkout] [01882b40-3767-7453-9720-cdfa48b5ae21] : Received input message.
[restate] [2023-05-17T19:46:48.808Z] [CheckoutService] [Checkout] [01882b40-3767-7453-9720-cdfa48b5ae21] : Call ended successful with output message.
[restate] [2023-05-17T19:46:48.850Z] [UserSessionService] [Checkout] [01882b40-3760-70c8-a2bc-7e0d889c11fb] : Received new completion from the runtime.
[restate] [2023-05-17T19:46:48.850Z] [UserSessionService] [Checkout] [01882b40-3760-70c8-a2bc-7e0d889c11fb] : Call ended successful with output message.
```

</details>
</>

## Reliable async communication without queues

Until now, we only did synchronous calls.
You can also do asynchronous calls via Restate, where you do not wait for the response. The syntax is very similar.
All we need to do is wrap the call with `inBackground`, as follows:

```typescript
async addTicket(request: ReserveTicket): Promise<BoolValue> {
    const ctx = restate.useContext(this);
    //highlight-start
    const ticketServiceClient = new TicketServiceClientImpl(ctx);
    await ctx.inBackground(() =>  ticketServiceClient.reserve(
        Ticket.create({ ticketId: request.ticketId })
    ));
    //highlight-end

    return BoolValue.create({ value: true });
}
```

Once you adapted the code, try it out by calling `UserSessionService/AddTicket`, as [explained earlier](#running-the-services-and-runtime).
If you look at the service logs, you see that the `addTicket` method doesn't wait for a response and finishes earlier than the `reserve` method.
<details><summary>Show the logs</summary>

```log
[restate] [2023-05-17T19:35:14.917Z] [UserSessionService] [AddTicket] [01882b35-a0e0-72b3-a87e-9335b5e0129c] : Received input message.
[restate] [2023-05-17T19:35:14.918Z] [UserSessionService] [AddTicket] [01882b35-a0e0-72b3-a87e-9335b5e0129c] : Adding message to output buffer: type: BackgroundInvoke
//highlight-next-line
[restate] [2023-05-17T19:35:14.918Z] [UserSessionService] [AddTicket] [01882b35-a0e0-72b3-a87e-9335b5e0129c] : Call ended successful with output message.
[restate] [2023-05-17T19:35:14.962Z] [TicketService] [Reserve] [01882b35-a0e7-727a-928a-1d69f34396fd] : Received input message.
//highlight-next-line
[restate] [2023-05-17T19:35:14.962Z] [TicketService] [Reserve] [01882b35-a0e7-727a-928a-1d69f34396fd] : Call ended successful with output message.
```

</details>

:::tip Good news!
Restate retries failed asynchronous invocations for you. No need to set up any message queues.
:::


### üìù Try it out
The `UserSessionService/ExpireTicket` method is called when a user did not proceed with the payment before the timeout.
Let the `expireTicket` method asynchronously call the `TicketService/Unreserve` method.
Send a request to `UserSessionSerivce/ExpireTicket` to check if it works.

<>
<details><summary>Solution</summary>

```typescript
async expireTicket(request: ExpireTicketRequest): Promise<Empty> {
    const ctx = restate.useContext(this);

        //highlight-start
    const ticketServiceClient = new TicketServiceClientImpl(ctx);
    await ctx.inBackground(() =>
        ticketServiceClient.unreserve(
            Ticket.create({ ticketId: request.ticketId })
        )
    );
        //highlight-end

    return {};
}
```

Call the `expireTicket` method with:
```shell
curl -X POST http://localhost:9090/example.UserSessionService/ExpireTicket -H 'content-type: application/json' -d '{"user_id": "123"}'
```

Have a look at the logs again to see what happened:

```log
[restate] [2023-05-17T20:04:12.562Z] [UserSessionService] [ExpireTicket] [01882b50-248c-77e8-b1e4-0b12e17f103b] : Received input message.
[restate] [2023-05-17T20:04:12.563Z] [UserSessionService] [ExpireTicket] [01882b50-248c-77e8-b1e4-0b12e17f103b] : Adding message to output buffer: type: BackgroundInvoke
//highlight-next-line
[restate] [2023-05-17T20:04:12.563Z] [UserSessionService] [ExpireTicket] [01882b50-248c-77e8-b1e4-0b12e17f103b] : Call ended successful with output message.
[restate] [2023-05-17T20:04:12.611Z] [TicketService] [Unreserve] [01882b50-2494-7fb1-9ab2-54a00956929d] : Received input message.
//highlight-next-line
[restate] [2023-05-17T20:04:12.611Z] [TicketService] [Unreserve] [01882b50-2494-7fb1-9ab2-54a00956929d] : Call ended successful with output message.
```

</details>
</>

:::info
üö© Explore the intermediate solution in `src/part1`, and run it with `npm run part1`.
:::

## Durable timers
:::note Implement it yourself or follow along by looking at the code under `src/part2`.
:::

Restate suspends a method invocation when it's waiting on external input.
The partial progress of the service invocation is durably stored in the log and can be resumed once
the external input has arrived.
Restate offers the same mechanism for timers.

### Suspendable sleep
You can do a durable, suspendable sleep with the Typescript SDK.
Earlier in this tutorial, we showed how Restate suspensions work by letting the ticket service sleep:
```typescript
async reserve(request: Ticket): Promise<BoolValue> {
    //bad-code-start
    await setTimeout(5000);
    //bad-code-end
    return BoolValue.create({value: true});
}
```
‚ùó This line of code would keep the service invocation running idly, and would not survive service restarts.

To use a durable, suspendable sleep, use the sleep functionality of the Restate SDK:
```typescript
async reserve(request: Ticket): Promise<BoolValue> {
    const ctx = restate.useContext(this);
    //good-code-start
    await ctx.sleep(5000);
    //good-code-end
    return BoolValue.create({value: true});
}
```

Run both services and send the `addTicket` request, as [we did earlier](#running-the-services-and-runtime).
In the service logs, you can see the `reserve` method processing the sleep, then suspending, and then resuming again after the sleep completed.
The `addTicket` method did an asynchronous call to the `reserve` method so did not suspend but just finished its invocation.

<details><summary>Show the logs</summary>

```log
[restate] [2023-05-18T06:30:10.476Z] [UserSessionService] [AddTicket] [01882d8d-3b2a-7f1c-a04a-d034ded45f5f] : Received input message.
[restate] [2023-05-18T06:30:10.476Z] [UserSessionService] [AddTicket] [01882d8d-3b2a-7f1c-a04a-d034ded45f5f] : Adding message to output buffer: type: BackgroundInvoke
[restate] [2023-05-18T06:30:10.476Z] [UserSessionService] [AddTicket] [01882d8d-3b2a-7f1c-a04a-d034ded45f5f] : Call ended successful with output message.
[restate] [2023-05-18T06:30:10.521Z] [TicketService] [Reserve] [01882d8d-3b2c-7db6-89fc-99d80e227f4b] : Received input message.
[restate] [2023-05-18T06:30:10.521Z] [TicketService] [Reserve] [01882d8d-3b2c-7db6-89fc-99d80e227f4b] : Adding message to output buffer: type: Sleep
//highlight-start
[restate] [2023-05-18T06:30:11.522Z] [TicketService] [Reserve] [01882d8d-3b2c-7db6-89fc-99d80e227f4b] : Call suspending.
//highlight-end
[restate] [2023-05-18T06:30:15.526Z] [TicketService] [Reserve] [01882d8d-3b2c-7db6-89fc-99d80e227f4b] : Received input message.
[restate] [2023-05-18T06:30:15.527Z] [TicketService] [Reserve] [01882d8d-3b2c-7db6-89fc-99d80e227f4b] : Call ended successful with output message.
```

</details>


Let's make the call to the `reserve` method synchronous again, to see how the suspensions work across different services.
Simply remove the `inBackground()` wrapper around the call, to end up with:

```ts
async addTicket(request: ReserveTicket): Promise<BoolValue> {
    const ctx = restate.useContext(this);

    const ticketServiceClient = new TicketServiceClientImpl(ctx);
    //highlight-start
    await ticketServiceClient.reserve(
        Ticket.create({ ticketId: request.ticketId })
    );
    //highlight-end

    return BoolValue.create({ value: true });
}
```

Now you see in the logs that both services get suspended. The user session service gets suspended because it waits for a response from the `reserve` method
    and the ticket service gets suspended because it waits for the sleep to be completed.
    Restate keeps track of how long the service should sleep and then triggers it to resume the invocation.
    Finally, we see the responses of both methods coming in.

<details><summary>Show the logs</summary>

```log
[restate] [2023-05-18T06:39:30.507Z] [UserSessionService] [AddTicket] [01882d95-c6c4-7a26-99f7-8dba0b476933] : Received input message.
[restate] [2023-05-18T06:39:30.508Z] [UserSessionService] [AddTicket] [01882d95-c6c4-7a26-99f7-8dba0b476933] : Adding message to output buffer: type: Invoke
[restate] [2023-05-18T06:39:30.510Z] [TicketService] [Reserve] [01882d95-c6cd-7271-aa3b-578216e44221] : Received input message.
[restate] [2023-05-18T06:39:30.510Z] [TicketService] [Reserve] [01882d95-c6cd-7271-aa3b-578216e44221] : Adding message to output buffer: type: Sleep
//highlight-start
[restate] [2023-05-18T06:39:31.509Z] [UserSessionService] [AddTicket] [01882d95-c6c4-7a26-99f7-8dba0b476933] : Call suspending.
[restate] [2023-05-18T06:39:31.512Z] [TicketService] [Reserve] [01882d95-c6cd-7271-aa3b-578216e44221] : Call suspending.
//highlight-end
[restate] [2023-05-18T06:39:35.513Z] [TicketService] [Reserve] [01882d95-c6cd-7271-aa3b-578216e44221] : Received input message.
[restate] [2023-05-18T06:39:35.514Z] [TicketService] [Reserve] [01882d95-c6cd-7271-aa3b-578216e44221] : Call ended successful with output message.
[restate] [2023-05-18T06:39:35.558Z] [UserSessionService] [AddTicket] [01882d95-c6c4-7a26-99f7-8dba0b476933] : Received input message.
[restate] [2023-05-18T06:39:35.559Z] [UserSessionService] [AddTicket] [01882d95-c6c4-7a26-99f7-8dba0b476933] : Call ended successful with output message.
```

</details>

:::caution
Sleeping can block processing for keyed and singleton services.
:::

[//]: # (TODO show this on minikube with knative in a little video)

### Delayed calls

Let's have a look at a slightly different usage of timers.
In the application, a ticket gets reserved for 15 minutes.
If it hasn't been bought and paid within that time interval, then it becomes available again to other users.

You can do delayed async calls with Restate by adding a delay in milliseconds to the
`inBackground` call.
```typescript
async addTicket(request: ReserveTicket): Promise<BoolValue> {
    const ctx = restate.useContext(this);

    const ticketServiceClient = new TicketServiceClientImpl(ctx);
    const success: BoolValue = await ticketServiceClient.reserve(
        Ticket.create({ ticketId: request.ticketId })
    );

    if (success.value) {
        const userSessionClient = new UserSessionServiceClientImpl(ctx);
        const expireTicketRequest = ExpireTicketRequest.create({
            userId: request.userId,
            ticketId: request.ticketId,
        });

        //highlight-start
        await ctx.inBackground(
            () => userSessionClient.expireTicket(expireTicketRequest),
            15 * 60 * 1000 // delay call for 15 minutes
        );
        //highlight-end
    }

    return success;
}
```

To test it out, put the delay to a lower value (e.g. 5 seconds), call the `addTicket` method, and see in the logs how the async call is executed 5 seconds later.

<details><summary>Show the logs</summary>

```logs
... logs from reserve call ...
[restate] [2023-05-18T07:14:32.546Z] [UserSessionService] [AddTicket] [01882db5-c61e-71d6-bd5c-4c4d8019c5fc] : Received input message.
[restate] [2023-05-18T07:14:32.549Z] [UserSessionService] [AddTicket] [01882db5-c61e-71d6-bd5c-4c4d8019c5fc] : Adding message to output buffer: type: BackgroundInvoke
[restate] [2023-05-18T07:14:32.550Z] [UserSessionService] [AddTicket] [01882db5-c61e-71d6-bd5c-4c4d8019c5fc] : Call ended successful with output message.
[restate] [2023-05-18T07:14:37.552Z] [UserSessionService] [ExpireTicket] [01882db5-d9e6-7165-9988-1b3381d4f209] : Received input message.
//highlight-next-line
[restate] [2023-05-18T07:14:37.552Z] [UserSessionService] [ExpireTicket] [01882db5-d9e6-7165-9988-1b3381d4f209] : Adding message to output buffer: type: BackgroundInvoke
[restate] [2023-05-18T07:14:37.553Z] [UserSessionService] [ExpireTicket] [01882db5-d9e6-7165-9988-1b3381d4f209] : Call ended successful with output message.
//highlight-next-line
[restate] [2023-05-18T07:14:37.598Z] [TicketService] [Unreserve] [01882db5-ed71-7087-b945-7c76bd5c6aca] : Received input message.
[restate] [2023-05-18T07:14:37.598Z] [TicketService] [Unreserve] [01882db5-ed71-7087-b945-7c76bd5c6aca] : Call ended successful with output message.
```

</details>

Don't forget to set the delay back to 15 minutes.

:::caution
You could also sleep for 15 minutes at the end of the `addTicket` method
and then call the `TicketService/Unreserve` method:

```typescript
await ctx.sleep(15 * 60 * 1000);
await ctx.inBackground(() =>
ticketServiceClient.unreserve(
  ExpireTicketRequest.create({
    userId: request.userId,
    ticketId: request.ticketId,
  })
));
```

Be aware that sleeping in a keyed service blocks any invocations for that key. So the user would not be able to add any other tickets, nor buy
the tickets.

If you do a sleep operation, the invocation is ongoing.
    If you do a delayed call, the invocation is not ongoing until the delay has passed, so no key is locked.

:::

## Persistent application state

Applications often need to keep state. For example, our user session service
needs to track the shopping cart items.

Restate offers a key-value store to persistently store application state.

:::tip Good news!
Restate's state is guaranteed to be consistent across retries and invocations.
This eliminates the need for a session database.
:::

The isolation level of the application state depends on the service type:
1. Keyed service: Application state is isolated per key. All the invocations for the
same key have access to the same application state. Restate's state feature is most
useful for
this service type.
2. Singleton service: All invocations to the service can access
the same state.
3. Unkeyed service: State is isolated per invocation. Using state is the least useful
for this service type.

Let's adapt the `UserSessionService/AddTicket` method to keep track of the cart items.
After successfully reserving the product, we add the ticket to the shopping cart.
    Have a look at the highlighted code:

```ts
async addTicket(request: ReserveTicket): Promise<BoolValue> {
    const ctx = restate.useContext(this);

    // ... reserve call returning success ...

    if (success.value) {
        //highlight-next-line
        const cart = (await ctx.get<string[]>("cart")) || [];
        cart.push(request.ticketId);
        //highlight-next-line
        ctx.set("cart", cart);

        // ... expireTicket call ...
    }

    return success;
}
```

To retrieve the cart, the first highlighted line calls `await ctx.get<T>(state_key: string)`.
This returns `null` if the value has never been set.

You can store multiple key-value pairs, by using different state keys.
Here, we get the value under the key `"cart"`.
    Restate ensures that we get the cart belonging to the current user ID (key of the service).

After we added the ticket to the cart array, the second highlighted line sets
    the state to the new value with `ctx.set(state_key: string, new_value: T)`.

Run the services and call the `addTicket` method, to see the interaction with state in the logs.

<details><summary>Show the logs</summary>

```log
... logs from reserve call ...
[restate] [2023-05-18T08:01:55.377Z] [UserSessionService] [AddTicket] [01882de1-26e2-766a-914f-81768d58f8fd] : Received input message.
//highlight-start
[restate] [2023-05-18T08:01:55.379Z] [UserSessionService] [AddTicket] [01882de1-26e2-766a-914f-81768d58f8fd] : Adding message to output buffer: type: GetState
[restate] [2023-05-18T08:01:55.380Z] [UserSessionService] [AddTicket] [01882de1-26e2-766a-914f-81768d58f8fd] : Received new completion from the runtime.
[restate] [2023-05-18T08:01:55.380Z] [UserSessionService] [AddTicket] [01882de1-26e2-766a-914f-81768d58f8fd] : Adding message to output buffer: type: SetState
//highlight-end
... logs from expireTicket call ...
```

</details>

We see that when we request the state, the runtime sends us a completion back.
The completion contains the current state value.
Finally, we set the new value.

Add a log statement to print the cart contents, and then call `addTicket` multiple times to see how the state gets updated:
```ts
console.info("Current cart content: " + JSON.stringify(cart));
```
You can also kill and relaunch the service or restart the runtime (`docker restart <container-name>`), to see that this has no influence on the cart contents.

:::info
You can store any object in the state as long as the value can be serialized with
`Buffer.from(JSON.stringify(yourObject))`.
:::

Let's also adapt the `checkout` method in the user session service, to use the cart contents:
```typescript
async checkout(request: CheckoutRequest): Promise<BoolValue> {
    const ctx = restate.useContext(this);

    // 1. Retrieve the cart from state
    //highlight-next-line
    const cart = await ctx.get<string[]>("cart");
    // 2. If there are no items in the cart, return `false`
    //highlight-start
    if (cart === null || cart.length === 0) {
        return BoolValue.create({ value: false });
    }
    //highlight-end

    // 3. Call the `checkout` method of the checkout service with the cart content
    const checkoutClient = new CheckoutServiceClientImpl(ctx);
    const checkoutFlowReq = CheckoutFlowRequest.create({
        userId: request.userId,
        //highlight-next-line
        tickets: cart,
    });
    const success = await checkoutClient.checkout(checkoutFlowReq);

    // 4. If this was successful, empty the cart.
    // Otherwise, let the user try again.
    if (success.value) {
        //highlight-next-line
        ctx.clear("cart");
    }
    return success;
}
```

Have a look at the logs to see how the code executes the workflow.

[//]: # (TODO add some text on how to run this and print the state )


### üìù Try it out
#### Finishing `UserSessionService/ExpireTicket`

We almost fully implemented the user session service.
Now that we implemented the checkout method, we can also finalize the `UserSessionService/ExpireTicket`.

At the moment we have the following code:
```ts
async expireTicket(request: ExpireTicketRequest): Promise<Empty> {
    const ctx = restate.useContext(this);

    const ticketServiceClient = new TicketServiceClientImpl(ctx);
    await ctx.inBackground(() =>
        ticketServiceClient.unreserve(
            Ticket.create({ ticketId: request.ticketId })
        )
    );

    return {};
}
```

Before we call `unreserve`, we first need to check if the ticket is still in the cart.
If this is the case, then we call `TicketService/Unreserve` and remove it from the cart state.

<details><summary>Solution</summary>

```ts
async expireTicket(request: ExpireTicketRequest): Promise<Empty> {
    const ctx = restate.useContext(this);

    const cart = await ctx.get<string[]>("cart");

    if (cart?.find((el) => el === request.ticketId)) {
        const ticketServiceClient = new TicketServiceClientImpl(ctx);
        await ctx.inBackground(() =>
            ticketServiceClient.unreserve(
                Ticket.create({ ticketId: request.ticketId })
            )
        );
        const newCart = cart.filter((el) => el !== request.ticketId);
        ctx.set("cart", newCart);
    }

    return {};
}
```

</details>


#### Implementing the ticket service
Let's track the status of the tickets in the ticket service by storing it in the state.

1. Implement the `TicketService/Reserve` method.
The method first retrieves the value for the `ticket_status` state key.
If the value is set to `"AVAILABLE"`, then change it to `"RESERVED"` and
return `true` (reservation successful). If the status is not set to `"AVAILABLE"`, then return `false`.
Remove the sleep that we used previously.

<>
<details><summary>Solution</summary>

```ts
async reserve(request: Ticket): Promise<BoolValue> {
    const ctx = restate.useContext(this);

    const ticketStatus = await ctx.get<string>("ticket_status");

    if(!ticketStatus || ticketStatus === "AVAILABLE"){
        ctx.set("ticket_status", "RESERVED")
        return BoolValue.create({ value: true });
    } else {
        return BoolValue.create({ value: false });
    }
}
```

Now, we can't reserve the same ticket multiple times anymore.
Call `addTicket` multiple times for the same ID. The first time it returns `true`,
afterwards `false`.
</details>
</>

2. Implement the `TicketService/Unreserve` method. The method should set the
value of the `"ticket_status"` key to `"AVAILABLE"`.

<>
<details><summary>Solution</summary>

```ts
async unreserve(request: Ticket): Promise<Empty> {
    const ctx = restate.useContext(this);

    ctx.set("ticket_status", "AVAILABLE");

    return {};
}
```

Now, the ticket reservation status switches back to `"AVAILABLE"` when the delayed call triggers.
Play around with reducing the delay of the `expireTicket` call in the `addTicket` method.
Try to reserve the same ticket ID multiple times, and see how you are able to reserve it again after the `unreserve` method was triggered.

</details>
</>

3. Implement the `TicketService/MarkAsSold` method. The method should set the
value of the `"ticket_status"` key to `"SOLD"`.


<>
<details><summary>Solution</summary>

```ts
async markAsSold(request: Ticket): Promise<Empty> {
    const ctx = restate.useContext(this);

    ctx.set("ticket_status", "SOLD");

    return {};
}
```

In the next section, we will implement the `CheckoutService/Checkout` method
that calls `markAsSold`. This will tie the final parts together.
</details>
</>

:::info
üö© Explore the intermediate solution in `src/part2`, and run it with `npm run part2`.
:::

## Side effects

:::note Implement it yourself or follow along by looking at the code under `src/part3`.
:::

Restate's replay mechanism makes applications resilient to failures.
But it also requires your code to be deterministic.

If you need to execute a non-deterministic code snippet (e.g. generating a UUID or
communicating to an external system) then you should wrap it in a side effect.
The side effect executes the supplied function and eagerly stores the return value in
Restate. Upon replay, the stored value gets inserted and the function does not get
re-executed.

:::tip
You can use a side effect to avoid re-execution during replay for any arbitrary piece of user code.
So also, for a piece of time-consuming, deterministic user code.
:::

Let's use a side effect in `CheckoutService/Checkout` to
create and store a UUID or idempotency key:
```typescript
import { v4 as uuid } from "uuid";

async checkout(request: CheckoutFlowRequest): Promise<BoolValue> {
    const ctx = restate.useContext(this);

    //highlight-start
    const idempotencyKey = await ctx.sideEffect<string>(async () => uuid());
    //highlight-end

    return BoolValue.create({ value: true });
}
```

The highlighted line of code wraps the creation of the UUID in a side effect
    with a string return type. When the `checkout()` method gets re-executed upon
    replay, Restate will inject the stored value.

To experiment, you can add a log line and a sleep to see how the UUID gets replayed after the suspension:
```ts
console.log("My idempotency key: " + idempotencyKey);
await ctx.sleep(2000);
```
Have a look at the logs to see what happens.

<details><summary>Show the logs</summary>

```log
[restate] [2023-05-18T10:42:55.029Z] [CheckoutService] [Checkout] [01882e74-9fb4-781b-9607-1e4b2ba75385] : Received input message.
//highlight-next-line
[restate] [2023-05-18T10:42:55.030Z] [CheckoutService] [Checkout] [01882e74-9fb4-781b-9607-1e4b2ba75385] : Adding message to output buffer: type: SideEffect
[restate] [2023-05-18T10:42:55.031Z] [CheckoutService] [Checkout] [01882e74-9fb4-781b-9607-1e4b2ba75385] : Received new completion from the runtime.
//highlight-next-line
My idempotency key: 5a0fa46f-88ec-4f29-b2e8-0b269bb44be2
[restate] [2023-05-18T10:42:55.031Z] [CheckoutService] [Checkout] [01882e74-9fb4-781b-9607-1e4b2ba75385] : Adding message to output buffer: type: Sleep
//highlight-next-line
[restate] [2023-05-18T10:42:56.031Z] [CheckoutService] [Checkout] [01882e74-9fb4-781b-9607-1e4b2ba75385] : Call suspending.
[restate] [2023-05-18T10:42:57.033Z] [CheckoutService] [Checkout] [01882e74-9fb4-781b-9607-1e4b2ba75385] : Received input message.
//highlight-next-line
My idempotency key: 5a0fa46f-88ec-4f29-b2e8-0b269bb44be2
[restate] [2023-05-18T10:42:57.034Z] [CheckoutService] [Checkout] [01882e74-9fb4-781b-9607-1e4b2ba75385] : Call ended successful with output message.
```

</details>

Remove the sleep again, before you continue.

:::caution
You can't execute any RestateContext calls from within a side effect.
    This will fail.
:::

### üìù Try it out
#### Executing the payment
The `checkout` method triggers the payment via some external payment provider, e.g.
Stripe. You can find a Stripe client stub in `src/aux/stripe_client.ts`. The Stripe
client has two methods:

- `get()` to create a new client,
- `call(idempotencyKey: string, amount: number)` to execute the payment for a certain
    idempotencyKey and total amount. Stripe makes sure that only one payment gets processed for a single
idempotency key.

Create a new Stripe client in `CheckoutService/checkout`. Assume every ticket costs 40 dollars.
    Then execute the payment with the created idempotency key and store the boolean result of the
    call as a side effect. Also use the boolean result for the return value of the method.

<details><summary>Solution</summary>

```typescript
async checkout(request: CheckoutFlowRequest): Promise<BoolValue> {
    const ctx = restate.useContext(this);

    const idempotencyKey = await ctx.sideEffect<string>(async () => uuid());

    const amount = request.tickets.length * 40;

    //highlight-start
    const stripe = StripeClient.get();

    const success = await ctx.sideEffect<boolean>(async () =>
        await stripe.call(idempotencyKey, amount)
    );
    //highlight-end

    return BoolValue.create({ value: success });
}
```

Add some tickets to your cart and then call `UserSessionService/Checkout`.
You should see logs similar to:

```logs
// ... UserSessionService/Checkout logs ...
[restate] [2023-05-18T11:56:47.384Z] [CheckoutService] [Checkout] [01882eb8-4196-7f45-95b4-2383518330af] : Received input message.
//highlight-next-line
[restate] [2023-05-18T11:56:47.384Z] [CheckoutService] [Checkout] [01882eb8-4196-7f45-95b4-2383518330af] : Adding message to output buffer: type: SideEffect
[restate] [2023-05-18T11:56:47.385Z] [CheckoutService] [Checkout] [01882eb8-4196-7f45-95b4-2383518330af] : Received new completion from the runtime.
//highlight-next-line
Executing stripe call for idempotency key 83205623-9259-4aca-8021-0dbdf3ce2854 and amount 40
//highlight-next-line
[restate] [2023-05-18T11:56:47.385Z] [CheckoutService] [Checkout] [01882eb8-4196-7f45-95b4-2383518330af] : Adding message to output buffer: type: SideEffect
[restate] [2023-05-18T11:56:47.385Z] [CheckoutService] [Checkout] [01882eb8-4196-7f45-95b4-2383518330af] : Received new completion from the runtime.
[restate] [2023-05-18T11:56:47.385Z] [CheckoutService] [Checkout] [01882eb8-4196-7f45-95b4-2383518330af] : Call ended successful with output message.
// ... UserSessionService/Checkout logs ...
```

You see the UserSessionService retrieving the cart and calling the checkout service.
The checkout service then does a side effect, the payment, and another side effect.
Finally, the checkout success is propagated back to the UserSessionService.

</details>

#### Finishing the checkout workflow
Once this works, let's implement the rest of the checkout workflow:
- If the Stripe call was successful, then:
    - do an async call to `TicketService/MarkAsSold` for each of the tickets
    - use the EmailClient in `src/aux/email_client.ts` to notify the users of the payment success.
    Prevent duplicate emails during retries by using a side effect.
- If the Stripe call was unsuccessful, then:
    - do an async call to `TicketService/Unreserve` for each of the ticket
    - use the EmailClient in `src/aux/email_client.ts` to notify the users of the payment failure.
    Prevent duplicate emails during retries by using a side effect.

<details><summary>Solution</summary>

```ts
async checkout(request: CheckoutFlowRequest): Promise<BoolValue> {
    const ctx = restate.useContext(this);

    const idempotencyKey = await ctx.sideEffect<string>(async () => uuid());

    const amount = request.tickets.length*40;

    const stripe = StripeClient.get();
    const success = await ctx.sideEffect<boolean>(async () =>
        await stripe.call(idempotencyKey, amount)
    );

    //highlight-start
    const ticketServiceClient = new TicketServiceClientImpl(ctx);
    const emailClient = EmailClient.get();

    if (success) {
        for await (const ticketId of request.tickets) {
            await ctx.inBackground(() =>
            ticketServiceClient.markAsSold(Ticket.create({ ticketId: ticketId }))
            );
        }
        emailClient.notifyUserOfPaymentSuccess(request.userId);
    } else {
        for await (const ticketId of request.tickets) {
            await ctx.inBackground(() =>
            ticketServiceClient.unreserve(Ticket.create({ ticketId: ticketId }))
            );
        }
        emailClient.notifyUserOfPaymentFailure(request.userId);
    }
    //highlight-end

    return BoolValue.create({ value: success });
}
```

</details>


ü•≥ Except for a few resiliency tweaks, you fully implemented the ticket reservation system!

:::info
üö© Explore the intermediate solution in `src/part3`, and run it with `npm run part3`.
:::
## Resiliency

:::note Implement it yourself or follow along by looking at the code under `src/part4`.
:::

As you have discovered throughout this tutorial, Restate makes your applications resilient out-of-the-box by:

- Making sure message can't get lost by durably storing all calls in the log. No
    more queues needed for async calls.
- Retrying failed invocations based on a specified retry policy. No more retry logic
    required for inter-service communication.
- Restoring partial progress of invocations, via its durable execution mechanism. For
    example, if a service goes down due to an infrastructure failure, the ongoing
    invocations will resume at the point in the user code where they left off.
- Ensuring consistent application state with its key-value store.
- Providing end-to-end exactly-once guarantees for incoming invocations.

:::tip Good news!
These features are switched on by default. No need to do anything.
:::

To tune the default retry policies of the runtime, have a look at the [Configuration docs](/deployment-operations/configuration).

### Side effect retries

If you do a side effect operation and the side effect fails,
    then this failure is durably stored in the log and it is not retried.
There are scenarios where you want to retry a failed side effect.
For example, when the side effect tries to execute a payment and the payment provider was temporarily offline.
The Typescript SDK offers some utilities for this. Let's activate retries for the
Stripe payment in `CheckoutService/Checkout`. Replace the previous call with:
```typescript
const stripe = StripeClient.get();
const doPayment = async () => stripe.failingCall(idempotencyKey, amount);
//highlight-start
const success: boolean = await RestateUtils.retryExceptionalSideEffectWithBackoff(
    ctx,
    doPayment,
    100, // initialDelayMs
    500, // maxDelayMs
    5 // maxRetries
);
//highlight-end
```
Also add the following import at the top `import { RestateUtils } from "@restatedev/restate-sdk";`.

We now call `stripe.failingCall` which will fail 2 times and then succeed.
The `retryExceptionalSideEffectWithBackoff` utility will make sure that if the retry fails, the service does a Restate sleep, and then tries again.
All attempts, including the sleeps are durably logged.
Have a look at the logs to see the retries.

<details><summary>Show the logs</summary>

```log
[restate] [2023-05-19T10:44:07.967Z] [CheckoutService] [Checkout] [0188339c-189e-725d-84ef-b23307451761] : Received input message.
[restate] [2023-05-19T10:44:07.968Z] [CheckoutService] [Checkout] [0188339c-189e-725d-84ef-b23307451761] : Adding message to output buffer: type: SideEffect
[restate] [2023-05-19T10:44:07.969Z] [CheckoutService] [Checkout] [0188339c-189e-725d-84ef-b23307451761] : Received new completion from the runtime.
Stripe call failed for idempotency key 851f1a19-456b-471b-841e-7da1dabac909 and amount 40. Retrying...
[restate] [2023-05-19T10:44:07.970Z] [CheckoutService] [Checkout] [0188339c-189e-725d-84ef-b23307451761] : Adding message to output buffer: type: SideEffect
[restate] [2023-05-19T10:44:07.970Z] [CheckoutService] [Checkout] [0188339c-189e-725d-84ef-b23307451761] : Received new completion from the runtime.
//highlight-start
[restate] [2023-05-19T10:44:07.970Z] DEBUG: Error while executing side effect 'unnamed-retryable-side-effect': Error - {"code":13,"message":"Stripe call failed"}
[restate] [2023-05-19T10:44:07.970Z] DEBUG: Retrying in 100 ms
//highlight-end
[restate] [2023-05-19T10:44:07.971Z] [CheckoutService] [Checkout] [0188339c-189e-725d-84ef-b23307451761] : Adding message to output buffer: type: Sleep
[restate] [2023-05-19T10:44:08.073Z] [CheckoutService] [Checkout] [0188339c-189e-725d-84ef-b23307451761] : Received new completion from the runtime.
Stripe call failed for idempotency key 851f1a19-456b-471b-841e-7da1dabac909 and amount 40. Retrying...
[restate] [2023-05-19T10:44:08.074Z] [CheckoutService] [Checkout] [0188339c-189e-725d-84ef-b23307451761] : Adding message to output buffer: type: SideEffect
[restate] [2023-05-19T10:44:08.075Z] [CheckoutService] [Checkout] [0188339c-189e-725d-84ef-b23307451761] : Received new completion from the runtime.
//highlight-start
[restate] [2023-05-19T10:44:08.075Z] DEBUG: Error while executing side effect 'unnamed-retryable-side-effect': Error - {"code":13,"message":"Stripe call failed"}
[restate] [2023-05-19T10:44:08.076Z] DEBUG: Retrying in 200 ms
//highlight-end
[restate] [2023-05-19T10:44:08.076Z] [CheckoutService] [Checkout] [0188339c-189e-725d-84ef-b23307451761] : Adding message to output buffer: type: Sleep
[restate] [2023-05-19T10:44:08.279Z] [CheckoutService] [Checkout] [0188339c-189e-725d-84ef-b23307451761] : Received new completion from the runtime.
//highlight-start
Stripe call succeeded for idempotency key 851f1a19-456b-471b-841e-7da1dabac909 and amount 40
//highlight-end
[restate] [2023-05-19T10:44:08.279Z] [CheckoutService] [Checkout] [0188339c-189e-725d-84ef-b23307451761] : Adding message to output buffer: type: SideEffect
[restate] [2023-05-19T10:44:08.281Z] [CheckoutService] [Checkout] [0188339c-189e-725d-84ef-b23307451761] : Received new completion from the runtime.
[restate] [2023-05-19T10:44:08.281Z] [CheckoutService] [Checkout] [0188339c-189e-725d-84ef-b23307451761] : Adding message to output buffer: type: BackgroundInvoke
Notifying user 123 of payment success
[restate] [2023-05-19T10:44:08.282Z] [CheckoutService] [Checkout] [0188339c-189e-725d-84ef-b23307451761] : Adding message to output buffer: type: SideEffect
[restate] [2023-05-19T10:44:08.284Z] [CheckoutService] [Checkout] [0188339c-189e-725d-84ef-b23307451761] : Received new completion from the runtime.
[restate] [2023-05-19T10:44:08.284Z] [CheckoutService] [Checkout] [0188339c-189e-725d-84ef-b23307451761] : Call ended successful with output message.
```

</details>

## Observability
Restate exposes OpenTelemetry traces of your invocations

Run the Jaeger container with:
```shell
docker run -d --name jaeger \
-e COLLECTOR_ZIPKIN_HTTP_PORT=9411 \
-p 6831:6831/udp \
-p 16686:16686 \
jaegertracing/all-in-one:1.45
```

Then restart the runtime with the Jaeger endpoint defined as an environment variable:
```shell
docker run -e RESTATE_OBSERVABILITY__JAEGER__ENDPOINT=localhost:6831 -e RUST_LOG=info,restate=info --network=host ghcr.io/restatedev/restate-dist:latest
```

Go to the Jaeger UI at [http://localhost:16686](http://localhost:16686).

Send requests to the runtime by adding tickets and checking out.
You should see traces similar to:

![Jaeger trace](/img/trace.png)

Note that async calls are shown as separate traces. So here, we only see the `UserSessionService/Checkout` and `CheckoutService/Checkout` calls,
    and not the async call to `TicketService/MarkAsSold`.

## üèÅ The end
You reached the end of this tutorial!

:::info üö© Have a look at the fully implemented app in `src/part4`, and run it with `npm run part4`.
:::

Let's recap what we covered:
- reliable, suspendable synchronous calls
- asynchronous calls without the need for queues
- suspensions for external communication
- durable timers for sleep or for calling other services
- concurrency guarantees for keyed/unkeyed/singleton services
- persistent application state
- storing the results of non-deterministic operations or external calls as side effects
- resiliency and retries
- observability with Jaeger

## Next steps
This tutorial did not cover anything related to deployment. 
In this tutorial, we ran the services as long-running services in Docker containers.
But Restate services can run with minimal changes on AWS Lambda. 

Possible next steps:
- [Deployment on AWS Lambda](/tutorials/running-on-lambda)
- [Deployment on Kubernetes](/tutorials/running-on-kubernetes)




