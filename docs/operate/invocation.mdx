---
sidebar_position: 2
description: "Explore the different ways to invoke Restate services."
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Admonition from '@theme/Admonition';

# Invocation

An invocation is a request to execute a handler that is part of either a service, or a virtual object.

There are different ways to invoke a handler:

* From within another handler, see the SDK docs for [TypeScript](/develop/ts/service-communication) or [Java/Kotlin](/develop/java/service-communication)
* By sending a request to Restate [over HTTP](/operate/invocation#invoking-handlers-over-http)
* [Via Kafka events](/operate/invocation#kafka-subscriptions)

## Invoking handlers over HTTP

You can invoke handlers over HTTP with or without waiting for a response, and with or without an idempotency key.

### Request-response calls over HTTP
You can invoke services over HTTP 1.1 or higher.
Request/response bodies should be encoded as JSON.

**To invoke Services**, construct the path as follows:

    ```shell
    curl localhost:8080/MyService/myHandler \
        -H 'content-type: application/json' \
        -d '{"name": "Mary", "age": 25}'
    ```


**To invoke Virtual Objects**, construct the path as follows:

    ```shell
    curl localhost:8080/MyVirtualObject/myObjectKey/myHandler \
        -H 'content-type: application/json' \
        -d '{"name": "Mary", "age": 25}'
    ```

<Admonition type="info" title="Restate as proxy">
Note that all invocations go first via the Restate Server. The server then forwards the request to the appropriate service.
Therefore, `localhost:8080` refers to ingress port of the Restate Server, not the service instance.
</Admonition>

### Sending a (delayed) message over HTTP
If you do not want to wait for the response, you can also send a message by adding `/send` to the URL path:

```shell
# focus[40:44]
curl localhost:8080/MyService/myHandler/send \
    -H 'content-type: application/json' \
    -d '{"name": "Mary", "age": 25}'
```

<details className={"grey-details"}>
    <summary>Output</summary>

    ```json
    {"invocationId":"inv_1aiqX0vFEFNH1Umgre58JiCLgHfTtztYK5"}
    ```
</details>

    The response contains the [Invocation identifier](#invocation-identifier).
You can use this identifier [to cancel](/operate/invocation#cancelling-invocations) or [kill the invocation](/operate/invocation#killing-invocations).

<Admonition type="tip">
    Use this to invoke long-running workflows.
</Admonition>

You can **delay the message** by adding a delay request parameter in ISO8601 notation or in seconds:

<CH.Code>

    ```shell seconds
    # focus[40:56]
    curl localhost:8080/MyService/myHandler/send?delaySec=10 \
    -H 'content-type: application/json' \
    -d '{"name": "Mary", "age": 25}'
    ```

    ```shell ISO8601
    # focus[40:56]
    curl localhost:8080/MyService/myHandler/send?delay=PT10S \
    -H 'content-type: application/json' \
    -d '{"name": "Mary", "age": 25}'
    ```

</CH.Code>



### Invoke a handler idempotently

You can send requests to Restate providing an idempotency key, through the [`Idempotency-Key` header](https://datatracker.ietf.org/doc/draft-ietf-httpapi-idempotency-key-header/):

```shell
curl localhost:8080/MyService/myHandler \
# focus
  -H 'idempotency-key: ad5472esg4dsg525dssdfa5loi' \
  -H 'content-type: application/json' \
  -d '{"name": "Mary", "age": 25}'
```

After the invocation completes, Restate persists the response for a retention period of one day (24 hours).
If you re-invoke the service with the same idempotency key within 24 hours, Restate sends back the same response and doesn't re-execute the request to the service.

<Admonition type="tip" title={"Make any service call idempotent by using Restate"}>
    By using Restate and an idempotency key, you can make any service call idempotent, without any extra code or setup.
    This is a very powerful feature to ensure that your system stays consistent and doesn't perform the same operation multiple times.
</Admonition>

<details className={"grey-details"}>
    <summary> Tuning retention time</summary>

    <CH.Section>
    You can tune the [retention time](focus://3) on a service-level by using the [Admin API](focus://1[15:28]) ([docs](/references/admin-api#tag/service/operation/modify_service)):
    ```shell
    curl -X PATCH localhost:9070/services/MyService \
        -H 'content-type: application/json' \
        -d '{"idempotency_retention": "2days"}'
    ```
    The [retention time](focus://3) is in [humantime format](https://docs.rs/humantime/latest/humantime/).
    </CH.Section>

</details>

### Private services
<CH.Section>
    When registering an endpoint, every service is by default reachable via HTTP requests.

    You can configure a service as `private`, such that you can't invoke it over HTTP, through the [Admin API](focus://1[15:28]) ([docs](/references/admin-api#tag/service/operation/modify_service)):

    ```shell
    curl -X PATCH localhost:9070/services/MyService \
        -H 'content-type: application/json' \
        -d '{"public": false}'
    ```

    You can revert it back to public with [`{"public": true}`](focus://3).

    <Admonition type="info">
        Private services can still be invoked by other handlers via the SDK.
    </Admonition>

</CH.Section>

## Kafka subscriptions

Restate can trigger handlers via Kafka events.
Have a look at the [Java](/develop/java/kafka) and [TypeScript](/develop/ts/kafka) docs to learn how to set up your handler to receive Kafka events.

<CH.Section>
- **Create subscriptions** for [a handler](focus://4) on [a topic](focus://3) via:
```bash
curl localhost:9070/subscriptions -H 'content-type: application/json' \
    -d '{
        "source": "kafka://my-cluster/my-topic",
        "sink": "service://MyService/Handle",
        "options": {"auto.offset.reset": "earliest"}
    }'
```
The [options field](focus://5) is optional and accepts any configuration parameter from [librdkafka configuration](https://github.com/confluentinc/librdkafka/blob/master/CONFIGURATION.md).
</CH.Section>
- **List** the current subscriptions via:
```bash
curl localhost:9070/subscriptions
```

<details className="grey-details">
    <summary>Output</summary>

    ```json
    {
        "subscriptions": [
            {
                "id": "sub_11XHoawrCiWtv8kzhEyGtsR",
                "source": "kafka://my-cluster/my-topic",
                "sink": "service://Greeter/greet",
                "options": {
                    "auto.offset.reset": "earliest",
                    "client.id": "restate",
                    "group.id": "sub_11XHoawrCiWtv8kzhEyGtsR"
                }
            }
        ]
    }
    ```

</details>

    The creation and listing of subscriptions returns an identifier.
<CH.Section>
    - **Delete** a subscription with [its identifier (starting with `sub_`)](focus://1[45:78]) via:
    ```bash
    curl -X DELETE localhost:9070/subscriptions/sub_11XHoawrCiWtv8kzhEyGtsR
    ```

    <Admonition type="info">
        When you delete a subscription, Restate stops the consumer group associated to it. Any messages that were already enqueued by Restate will still be processed.
    </Admonition>
</CH.Section>


## Invocation identifier

Restate assigns an identifier to every invocation, the Invocation ID. You can use this Invocation ID to inspect the invocation via the CLI, filter the logs, find traces, cancel it, etc.

The invocation ID starts with `inv_`, and can be found in the logs and traces (`restate.invocation.id`), for example:

<CH.Code>
```log TypeScript
// focus[37:74]
[restate] [CartObject/expireTicket][inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz][2024-03-18T16:14:24.671Z] DEBUG: Invoking function.
```

```log Java
    // focus[53:90]
2024-04-16 17:27:45 INFO  [CartObject/expireTicket][inv_1aiqX0vFEFNH0T0mRlvCk7xTVSB5xQIaKR] dev.restate.sdk.core.ResolvedEndpointHandlerImpl - Start invocation
```
</CH.Code>

Or you can use the CLI to list the invocations and retrieve the ID from there:
```shell
restate inv ls
```
<details className={"grey-details"}>
<summary>Output</summary>

```shell
# focus[36:74]
‚ùØ [2024-04-16 15:28:20.237 +02:00] inv_1aiqX0vFEFNH0TF1pLRFBDFosQCCTAN1M5 [CartObject @ Mary]::addTicket
Status:      backing-off  (4 minutes, 42 seconds and 653 ms. Retried 32 time(s). Next
retry in in 9 seconds and 469 ms))
Deployment:  dp_14LsPzGz9HBxXIeBoH5wYUh [required]
Error:       [2024-04-16 15:33:01.930 +02:00]
[500] Failing

Showing 1/1 invocations. Query took 86.295361ms
```
</details>



## Cancelling invocations

If an invocation takes too long to complete or is no longer of interest, you can cancel it.
Canceling an invocation allows it to free any resources it is holding and roll back any changes it has made so far.

<Tabs groupId="interface" queryString>
<TabItem value="cli" label="CLI">

<CH.Section>
You can cancel the invocation with [its ID](focus://1[19:58]) ([docs](/operate/invocation?interface=curl#invocation-identifier)) using the CLI:

```shell
restate inv cancel inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz
```
</CH.Section>

You can also use the abbreviation `rm` instead of `cancel`.


</TabItem>
<TabItem value="curl" label="curl">
<CH.Section>
You can cancel the invocation with [its ID](focus://1[50:90]) ([docs](/operate/invocation?interface=curl#invocation-identifier)) using [the Admin API](focus://1[23:36]) ([docs](/references/admin-api)):

```shell
curl -X DELETE http://localhost:9070/invocations/inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz
```

</CH.Section>

</TabItem>
</Tabs>

<Admonition type="info" title={"Implement compensation logic"}>
To roll back correctly, the handlers need to contain the necessary compensation logic.
This way, the service state stays consistent even in the presence of cancellations.
Have a look at [this blog post](https://restate.dev/blog/graceful-cancellations-how-to-keep-your-application-and-workflow-state-consistent/) on how to implement compensation logic with Restate.
</Admonition>

<Admonition type="info">
    Canceling an invocation is a non-blocking operation. This means that the cancellation is not guaranteed to have completed when the API call returns. In some rare cases, cancellations will not have an effect. In these cases, users need to retry the operation.
</Admonition>

<details className={"grey-details"}>
    <summary>How does cancellation work?</summary>

    The cancellation process works recursively in the following way:
    First, Restate tries to cancel the leaves of the current invocation, i.e. interrupt ongoing sleeps and awakeables or try to cancel calls to other services.
    Once the leaves are canceled, a terminal error is thrown in the service handler at the point in the code that the invocation had reached.
    This allows the handler to run its specific compensation logic.
    The response of the handler will then be propagated back to its caller where it will continue with the cancellation process.

</details>


## Killing invocations

Sometimes Restate cannot cancel an invocation.
For example, when an endpoint is permanently unavailable, Restate can't invoke the handler to run its compensation logic, so it can't complete the cancellation.
For these cases, you can kill invocations.
<Tabs groupId="interface" queryString>
<TabItem value="cli" label="CLI">

Kill the invocation by using [cancel](/operate/invocation?interface=cli#cancelling-invocations) with the `--kill` flag:

```shell
restate inv cancel --kill inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz
```

You can also use the abbreviation `rm` instead of `cancel`.

</TabItem>
<TabItem value="curl" label="curl">

To kill an invocation, add `?mode=kill` to the [cancel request](/operate/invocation?interface=curl#cancelling-invocations):

```shell
# focus[88:97]
curl -X DELETE http://localhost:9070/invocations/inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz?mode=kill
```
</TabItem>
</Tabs>


<Admonition type="warning">
    One-way calls and delayed calls will not be killed because they are detached from the originating call tree.
</Admonition>

<Admonition type="warning" title={"Watch out for inconsistency"}>
    Killing an invocation immediately stops every call in the call tree of the invocation.
    **Handlers will not execute compensation logic.**
    This might leave the service instance in an inconsistent state.
    Use it with caution and try fixing the invocation in other ways before resorting to killing it.
</Admonition>