---
sidebar_position: 3
description: ""
---

import {Scrollycoding} from "../../src/components/code/scrollycoding";

# Services

import Admonition from '@theme/Admonition';

This is what a Restate application looks like from a helicopter view:

<center>
    <img src="/img/restate-app.svg" alt="Application overview" width="50%"/>
</center>

1. **Restate Server**: The server intercepts incoming requests and drives their execution till the end.
2. **Services**: Contain the handlers which process incoming requests.
3. **Invocation**: A request to execute a handler that is part of either a service, or a virtual object.

As you can see, handlers are bundled into services.
Services run like regular RPC services (e.g. a NodeJS app in a Docker container).
Services can be written in any language for which there is an SDK available.

There are three types of services in Restate:

[//]: # (This is an html table because markdown tables don't support setting the column width and for some reason the workflow column was very large)
<table><thead><tr><th>Services (plain)</th><th>Virtual objects</th><th>Workflows</th></tr></thead><tbody><tr><td width={"30%"}>Set of handlers durably executed</td><td width={"30%"}>Set of handlers durably executed</td><td width={"30%"}>The workflow <code>run</code> handler is durably executed a single time.</td></tr><tr><td>No associated K/V store</td><td>Handlers share K/V state; isolated per virtual object</td><td>K/V state isolated per workflow execution. Can only be set by the <code>run</code> handler.</td></tr><tr><td>No concurrency limits</td><td> To guard state consistency, only one handler with write access to the state can run at a time per virtual object (key). Handlers marked as shared don't have write access and can run concurrently to the exclusive handlers.</td><td>The <code>run</code> handler can run only a single time. Other handlers can run concurrently to interact with the workflow.</td></tr><tr><td>Example use cases: <ul><li>Microservice orchestration</li><li>To benefit from idempotency</li><li>Transformation functions</li><li>Sagas</li></ul></td><td>Example use cases: <ul><li>Atomic state machines</li><li>Digital twin</li><li>Locking mechanisms</li><li>Sequencing or ordering invocations</li></ul></td><td>Example use cases: <ul><li>Order processing and logistics</li><li>User sign-up workflow</li><li>Infrastructure provisioning</li><li>Workflow interpreters</li></ul></td></tr></tbody></table>

## Services

Services expose a collection of handlers:

<Scrollycoding>
    ## !!steps
    Restate makes sure that **handlers run to completion**, even in the presence of failures.
    Restate logs the **results of actions** in the system.
    Restate takes care of retries and recovers the handler to the point where it failed.

    ```ts !!tabs TypeScript
    CODE_LOAD::ts/src/concepts/services.ts?1
    ```
    ```java !!tabs Java
    CODE_LOAD::java/src/main/java/concepts/services/RoleUpdateService.java?1
    ```
    ```go !!tabs Go
    CODE_LOAD::go/concepts/services/main.go?1
    ```
    ```python !!tabs Python
    CODE_LOAD::python/src/concepts/services.py?1
    ```

    ## !!steps
    The handlers of services are **independent** and can be **invoked concurrently**.

    ```ts !!tabs TypeScript
    CODE_LOAD::ts/src/concepts/services.ts?2
    ```
    ```java !!tabs Java
    CODE_LOAD::java/src/main/java/concepts/services/RoleUpdateService.java?2
    ```
    ```go !!tabs Go
    CODE_LOAD::go/concepts/services/main.go?2
    ```
    ```python !!tabs Python
    CODE_LOAD::python/src/concepts/services.py?2
    ```

    ## !!steps
    Handlers use the regular code and control flow, no custom DSLs.

    ```ts !!tabs TypeScript
    CODE_LOAD::ts/src/concepts/services.ts?3
    ```
    ```java !!tabs Java
    CODE_LOAD::java/src/main/java/concepts/services/RoleUpdateService.java?3
    ```
    ```go !!tabs Go
    CODE_LOAD::go/concepts/services/main.go?3
    ```
    ```python !!tabs Python
    CODE_LOAD::python/src/concepts/services.py?3
    ```
</Scrollycoding>


## Virtual objects

Virtual objects expose a set of handlers with access to K/V state stored in Restate.

<Scrollycoding>

    ## !!steps
    A virtual object is **uniquely identified and accessed by its key**.

    ```ts !!tabs TypeScript
    CODE_LOAD::ts/src/concepts/virtual_objects.ts?1
    ```
    ```java !!tabs Java
    CODE_LOAD::java/src/main/java/concepts/services/Greeter.java?1
    ```
    ```go !!tabs Go
    CODE_LOAD::go/concepts/virtualobjects/main.go?1
    ```
    ```python !!tabs Python
    CODE_LOAD::python/src/concepts/virtual_objects.py?1
    ```

    ## !!steps
    Each virtual object has access to its own **isolated K/V state**, stored in Restate.
    The handlers of a virtual object can read and write to the state of the object.
    Restate delivers the state together with the request to the virtual object, so virtual objects have their state locally accessible without requiring any database connection or lookup.
    State is exclusive, and atomically committed with the method execution.

    ```ts !!tabs TypeScript
    CODE_LOAD::ts/src/concepts/virtual_objects.ts?2
    ```
    ```java !!tabs Java
    CODE_LOAD::java/src/main/java/concepts/services/Greeter.java?2
    ```
    ```go !!tabs Go
    CODE_LOAD::go/concepts/virtualobjects/main.go?2
    ```
    ```python !!tabs Python
    CODE_LOAD::python/src/concepts/virtual_objects.py?2
    ```

    ## !!steps
    To ensure consistent writes to the state, Restate provides **concurrency guarantees**: at most one handler can execute at a time for a given virtual object.
    This can also be used for example to implement a locking mechanism or to ensure single writer to a database row.

    ```ts !!tabs TypeScript
    CODE_LOAD::ts/src/concepts/virtual_objects.ts?3
    ```
    ```java !!tabs Java
    CODE_LOAD::java/src/main/java/concepts/services/Greeter.java?3
    ```
    ```go !!tabs Go
    CODE_LOAD::go/concepts/virtualobjects/main.go?3
    ```
    ```python !!tabs Python
    CODE_LOAD::python/src/concepts/virtual_objects.py?3
    ```

</Scrollycoding>

## Workflows

A workflow is a special type of Virtual Object that can be used to implement a set of steps that need to be executed durably.
Workflows have additional capabilities such as signaling, querying, additional invocation options, and a longer retention time in the CLI.

<Scrollycoding>

    ## !!steps
    A workflow has a **`run` handler** that implements the **workflow logic**.
    The `run` handler runs exactly once per workflow ID (object).

    ```ts !!tabs TypeScript
    CODE_LOAD::ts/src/concepts/workflow.ts?1
    ```
    ```java !!tabs Java
    CODE_LOAD::java/src/main/java/concepts/services/Payment.java?1
    ```
    ```python !!tabs Python
    CODE_LOAD::python/src/concepts/workflows.py?1
    ```

    ## !!steps
    You can **query the workflow** by defining other handlers in the same object.
    For example, you can store state in the workflow object, and query it from other handlers.

    ```ts !!tabs TypeScript
    CODE_LOAD::ts/src/concepts/workflow.ts?2
    ```
    ```java !!tabs Java
    CODE_LOAD::java/src/main/java/concepts/services/Payment.java?2
    ```
    ```python !!tabs Python
    CODE_LOAD::python/src/concepts/workflows.py?2
    ```

    ## !!steps
    You can **signal the workflow**, to send information to it, via Durable Promises.
    For example, the payment provider signals the workflow that the payment was successful by calling the `paymentWebhook`.

    ```ts !!tabs TypeScript
    CODE_LOAD::ts/src/concepts/workflow.ts?3
    ```
    ```java !!tabs Java
    CODE_LOAD::java/src/main/java/concepts/services/Payment.java?3
    ```
    ```python !!tabs Python
    CODE_LOAD::python/src/concepts/workflows.py?3
    ```

</Scrollycoding>

<Admonition type="note">
    The `run` handler is the only handler that can **write K/V state**.
    The other handlers are able to run concurrently to the `run` handler, and can get state but cannot set it.
</Admonition>

## Restate Server

In between the services, sits the Restate Server. It proxies invocations to the services and manages their lifecycle.

The Restate Server is written in Rust, to be self-contained and resource-efficient.
It has an event-driven foundation. You can put it in the hot, latency-sensitive paths of your applications.

The main feature the Restate Server provides is Durable Execution. We dive into this in a [later section](/concepts/durable_execution).

The Restate Server runs as a single binary with zero dependencies. It runs with low operational overhead on any platform, also locally.
To deploy the Restate Server, have a look at these deployment guides:

- [Kubernetes](/deploy/server/kubernetes)
- [EC2](/deploy/server/self-hosted)
