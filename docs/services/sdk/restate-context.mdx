---
sidebar_position: 2
description: "Learn how to interact with the runtime via the Restate context."
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Restate context

In Restate services, all interaction with the runtime occurs through the Restate context.
This context provides a set of methods that allow you to perform actions such as getting or setting state, or
calling other services.

You can retrieve the context object as follows:

<Tabs groupId="sdk" queryString>
<TabItem value="ts" label="TypeScript" default>

```typescript
import * as restate from "@restatedev/restate-sdk";

const greet = async (ctx: restate.Context, name: string) => {

    //...the rest of your code...
};
```

The Restate context is supplied as the first argument `ctx` to the handler.
The arguments behind that are optional. For more information on the handler signature, have a look at the [serving docs](/services/sdk/serving).

If you use a keyed service, and you want your invocations to be keyed, you need to use the keyed context.
This is required to use Restate's K/V state store.

```typescript
import * as restate from "@restatedev/restate-sdk";

const greet = async (ctx: restate.KeyedContext, name: string) => {

    //...the rest of your code...
};
```

</TabItem>
<TabItem value="ts-grpc" label="TypeScript-gRPC">


```typescript
import * as restate from "@restatedev/restate-sdk";

async greet(request: Request): Promise<Response> {
  const ctx = restate.useContext(this);

  //...the rest of your code...
}
```

If you use a keyed service, and you want your invocations to be keyed, you need to use the keyed context.
This is required to use Restate's K/V state store.

```typescript
import * as restate from "@restatedev/restate-sdk";

async greet(request: Request): Promise<Response> {
    const ctx = restate.useKeyedContext(this);

    //...the rest of your code...
};
```

</TabItem>

<TabItem value="java" label="Java">

The Restate context is supplied as the first argument `ctx` to the method.

For example:

```java
public class Greeter extends GreeterRestate.GreeterRestateImplBase {

  @Override
  public GreetResponse greet(Context ctx, GreetRequest request) {
    // implement your method
  }
}
```

If you use a keyed service, and you want your invocations to be keyed, you need to use the object context.
This is required to use Restate's K/V state store.

```java
public class Greeter extends GreeterRestate.GreeterRestateImplBase {

    @Override
    public GreetResponse greet(ObjectContext ctx, GreetRequest request) {
        // implement your method
    }
}
```

:::note
Have a look at the [Context JavaDocs](https://javadoc.io/doc/dev.restate/sdk-api/latest/dev/restate/sdk/Context.html) and [ObjectContext JavaDocs](https://javadoc.io/doc/dev.restate/sdk-api/latest/dev/restate/sdk/ObjectContext.html) for an overview of what you can do with the Restate context.
:::

<details>
<summary>Alternative: vanilla gRPC</summary>

If you do not use Restate's generated protobuf code, you can access the restate context as follows:

```java
import dev.restate.sdk.Context;

// Inside your method:
Context ctx = Context.current();
```

For the keyed context, do:

```java
import dev.restate.sdk.ObjectContext;

// Inside your method:
ObjectContext ctx = ObjectContext.current();
```

</details>

</TabItem>
</Tabs>


:::info
The code blocks in the documentation refer to the Restate Context via the variable named `ctx`.
:::

:::caution 
All method calls made through the Restate context are durably stored in the execution log
and can be replayed in case of failure, ensuring that your service is always reliable and fault-tolerant.
This means that if you do actions (e.g. calling other services, sleep) without making use of the Restate SDK,
you do not have these benefits.
:::

:::danger
If you want to have at most one ongoing invocation per key (e.g. when interacting with state),
make sure you use the ObjectContext (for Java) or KeyedContext (for TypeScript).
The ObjectContext makes sure that invocations are sequenced per key. So there is at most one ongoing invocation for a specific key.
This guarantees that at most one function is changing the state for a specific key.
This is required to prevent inconsistent state when multiple invocations would be writing to the same key.
:::