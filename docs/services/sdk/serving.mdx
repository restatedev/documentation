---
sidebar_position: 11
description: "Set up long-running services or Lambda handlers."
---


import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Serving
Restate services can run in two ways: as long-running services or as AWS Lambda functions.

## Restate server for long-running services

To register your service as a long-running service, do the following:

<Tabs groupId="sdk" queryString>
<TabItem value="ts" label="TypeScript" default>

**1. Define a router for your keyed or unkeyed service**

This router is used to link the function you implemented with an API path. 

For **unkeyed services**, the router looks as follows:

```typescript
const serviceRouter = restate.router({
    hello: async () => { ... },
    callMe: async (ctx: restate.RpcContext) => { ... },
    maybe: async (ctx: restate.RpcContext, request: Request) => { ... }
});
```

This example shows a router for an unkeyed service with three functions and their respective API paths (`hello`, `callMe`, and `maybe`).
This means that the `hello` function can be called via `<RESTATE_INGRESS_URL>/myServicePath/hello`.

The functions of an unkeyed router have two optional parameters:

- A `ctx` of type `restate.RpcContext` which allows to interact with Restate.
- A `request` of type JSON object that represents additional invocation data.

The parameter names may be chosen differently.

For **keyed services**, the router looks as follows:
```typescript
// 2. Create a router for keyed services (if any):
const keyedServiceRouter = restate.keyedRouter({
    hello: async () => { ... },
    callMe: async (ctx: restate.RpcContext) => { ... },
    maybe: async (ctx: restate.RpcContext, key: string) => { ... },
    withSomething: async (ctx: restate.RpcContext, key: string, request: Request) => { ... }
});
```

This example shows a router for a keyed service with four functions and their respective API paths (`hello`, `callMe`, `maybe`, and `withSomething`).
This means that the `hello` function can be called via `<RESTATE_INGRESS_URL>/myServicePath/hello`.

The functions of a keyed router have three optional parameters:

- A `ctx` of type `restate.RpcContext` which allows to interact with Restate.
- A `key` parameter of type string which represents the key of the invoked service.
- A `request` parameter of type JSON object which represents additional invocation data.

The parameter names may be chosen differently.

**2. Export the service API**

You use the exported serviceApi to call this service from within other services (see [service communication docs](/services/sdk/service-communication))

```typescript
export const myServiceApi: restate.ServiceApi<typeof serviceRouter> = {
    path: "myServicePath",
};

// use the same syntax for keyed services:
export const myKeyedServiceApi: restate.ServiceApi<typeof keyedServiceRouter> = {
    path: "myServicePath",
};
```
This means that the `hello` function of this service can be called via `<RESTATE_INGRESS_URL>/myServicePath/hello`.

**3. Create the server**

Create the server. Then, bind the services with `bindRouter` for unkeyed services and `bindKeyedRouter` for keyed services.
You need to supply the service path and router. 
Finally, let the server listen on a specified port (default is `9080`):

```typescript
restate
  .createServer()
  // bind the keyed services to the Restate server
  .bindRouter(myServiceApi.path, serviceRouter)
  // bind the unkeyed services to the Restate server
  .bindKeyedRouter(myKeyedServiceApi.path, keyedServiceRouter)
  .listen();
```


</TabItem>
<TabItem value="ts-grpc" label="TypeScript-gRPC">

```typescript
restate
  .createServer()
  .bindService({
    descriptor: protoMetadata,
    service: "Greeter",
    instance: new GreeterService(),
  })
  .listen();
```

First, call the `createServer()` method to create a new `RestateServer`.

Then, bind one or multiple services to the server.
- As `descriptor`, you need to provide the `protoMetadata` that was generated by the Protobuf code generator. 
- The value assigned to `service` should correspond to the name of the service defined in the Protobuf service definition. This code example assumes the service is called `Greeter`. This means that the Protobuf definition includes the following:
```protobuf
service Greeter {
  // Definition of the methods
  //...
}
```
- For the `instance` field, provide an instance of the service implementation. 

Finally, call `listen(port?)` to have the RestateServer listen on the specified port for connections and requests.

</TabItem>

<TabItem value="java" label="Java">

```java
RestateHttpEndpointBuilder.builder().withService(new Greeter()).buildAndListen();
```

First, create a `RestateHttpEndpointBuilder`, then bind one or multiple services to the server.

Finally, call `buildAndListen(port)` to have the RestateServer listen on the specified port for connections and requests.

</TabItem>
</Tabs>

## Restate Lambda handler

To register your service as a Lambda function,
only minimal changes are required, as compared to the long-running service:

<Tabs groupId="sdk" queryString>
<TabItem value="ts" label="TypeScript" default>

```typescript
export const handler = restate
    //highlight-next-line
  .createLambdaApiGatewayHandler()
  .bindRouter(myServiceApi.path, serviceRouter)
  .bindKeyedRouter(myKeyedServiceApi.path, keyedServiceRouter)
    //highlight-next-line
  .handle();
```

Implement a `LambdaRestateServerFactory` with a `create` method that returns a `LambdaRestateServer` with the services binded to it.

Have a look at the [deployment](/services/deployment/lambda/lambda-typescript) section
for guidance on how to deploy your services on AWS Lambda.

</TabItem>
<TabItem value="ts-grpc" label="TypeScript-gRPC">

```typescript
export const handler = restate
    //highlight-next-line
    .createLambdaApiGatewayHandler()
    .bindService({
        descriptor: protoMetadata,
        service: "Greeter",
        instance: new GreeterService(),
    })
    //highlight-next-line
    .handle();
```

Implement a `LambdaRestateServerFactory` with a `create` method that returns a `LambdaRestateServer` with the services binded to it.

Have a look at the [deployment](/services/deployment/lambda/lambda-typescript) section
for guidance on how to deploy your services on AWS Lambda.


</TabItem>
<TabItem value="java" label="Java">

Add the following dependency to your project, for example, using Gradle:

```kotlin
implementation("dev.restate:sdk-lambda:VAR::JAVA_SDK_VERSION")
```

Register your Lambda services as follows:

```java
import dev.restate.sdk.lambda.LambdaRestateServer;
import dev.restate.sdk.lambda.LambdaRestateServerFactory;

public class MyLambdaHandler extends BaseRestateLambdaHandler {
  @Override
  public void register(RestateLambdaEndpointBuilder builder) {
    builder.withService(new Greeter());
  }
}
```

Create a class that extends `BaseRestateLambdaHandler` with your services binded to it.

Have a look at the [deployment](/services/deployment/lambda/lambda-java) section
for guidance on how to deploy your services on AWS Lambda.

</TabItem>
</Tabs>


:::info 
That's all you need to do to enable running on AWS Lambda.
The implementation of your service methods remains the same for both deployment options.
:::


