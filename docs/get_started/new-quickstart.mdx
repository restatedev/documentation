---
id: new-quickstart
[//]: # (sidebar_position: 2 --> this is now set by sidebars.js)
description: ""
toc: false
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Admonition from '@theme/Admonition';
import {Step} from "../../src/components/Stepper";
import {CodeWithTabs} from "../../src/components/code/code";
import {
    Terminal,
    TerminalWithTabs
} from "../../src/components/code/terminal";
import {TextAndCode} from "../../src/components/code/code/text-and-code";
import {Scrollycoding} from "../../src/components/code/scrollycoding";

# Getting Started
This guide takes you through your first steps with Restate.

## Quickstart
Let's first get our setup working.

We will run a simple Restate Greeter service that listens on port `9080` and responds with `Hi!` to a `greet` request.

<img src="/img/quickstart/overview.svg" alt="Quickstart" className="quickstart-image" width="400rem"/>

<Admonition type="note" title="Prerequisites">
    - [NodeJS](https://nodejs.org/en/) >= v18.17.1
    - [npm CLI](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm) >= 9.6.7
</Admonition>

<Step stepLabel="1" title="Install Restate Server & CLI">
    Restate is a single self-contained binary. No external dependencies needed.

    <Tabs groupId={"running-restate"}>
        <TabItem value={"Homebrew"} label={"Homebrew"}>
            <TextAndCode>
                Install Restate Server and CLI.

                ```shell !result
                brew install restatedev/tap/restate-server &&
                brew install restatedev/tap/restate
                ```
            </TextAndCode>
            <TextAndCode>
                Then run the Restate Server with:
                ```shell !result
                restate-server
                ```
            </TextAndCode>
        </TabItem>
        <TabItem value={"bin"} label={"Download binaries"}>
            Install the Restate Server and CLI by downloading the binaries with `curl` from the [releases page](https://github.com/restatedev/restate/releases/latest), and make them executable:

            <CodeWithTabs>
                ```shell !!tabs Linux-x64
                BIN=$HOME/.local/bin && RESTATE_PLATFORM=x86_64-unknown-linux-musl && \
                curl -LO https://github.com/restatedev/restate/releases/latest/download/restate.$RESTATE_PLATFORM.tar.gz && \
                tar -xvf restate.$RESTATE_PLATFORM.tar.gz && \
                chmod +x restate restate-server && \

                # Move the binaries to a directory in your PATH, for example ~/.local/bin:
                mv restate $BIN && \
                mv restate-server $BIN
                ```

                ```shell !!tabs Linux-arm64
                BIN=$HOME/.local/bin && RESTATE_PLATFORM=aarch64-unknown-linux-musl && \
                curl -LO https://github.com/restatedev/restate/releases/latest/download/restate.$RESTATE_PLATFORM.tar.gz && \
                tar -xvf restate.$RESTATE_PLATFORM.tar.gz && \
                chmod +x restate restate-server && \

                # Move the binaries to a directory in your PATH, for example ~/.local/bin:
                mv restate $BIN && \
                mv restate-server $BIN
                ```

                ```shell !!tabs MacOS-x64
                BIN=/usr/local/bin && RESTATE_PLATFORM=x86_64-apple-darwin && \
                curl -LO https://github.com/restatedev/restate/releases/latest/download/restate.$RESTATE_PLATFORM.tar.gz && \
                tar -xvf restate.$RESTATE_PLATFORM.tar.gz && \
                chmod +x restate restate-server && \

                # Move the binaries to a directory in your PATH, for example /usr/local/bin (needs sudo):
                sudo mv restate $BIN && \
                sudo mv restate-server $BIN
                ```

                ```shell !!tabs MacOS-arm64
                BIN=/usr/local/bin && RESTATE_PLATFORM=aarch64-apple-darwin && \
                curl -LO https://github.com/restatedev/restate/releases/latest/download/restate.$RESTATE_PLATFORM.tar.gz && \
                tar -xvf restate.$RESTATE_PLATFORM.tar.gz && \
                chmod +x restate restate-server && \

                # Move the binaries to a directory in your PATH, for example /usr/local/bin (needs sudo):
                sudo mv restate $BIN && \
                sudo mv restate-server $BIN
                ```

            </CodeWithTabs>

            Then run the Restate Server with:
            ```shell
            restate-server
            ```

        </TabItem>
        <TabItem value={"npm"} label={"npm"}>
            <TextAndCode>
                Install Restate Server and CLI via:

                ```shell !result
                npm install --global @restatedev/restate-server@latest &&
                npm install --global @restatedev/restate@latest
                ```
            </TextAndCode>
            <TextAndCode>
                Then run the Restate Server with:
                ```shell !result
                restate-server
                ```
            </TextAndCode>
        </TabItem>
        <TabItem value={"Docker"} label={"Docker"}>

            To run the Restate Server:

            ```shell
            docker run --name restate_dev --rm -p 8080:8080 -p 9070:9070 -p 9071:9071 \
            --add-host=host.docker.internal:host-gateway docker.io/restatedev/restate:VAR::RESTATE_VERSION
            ```

            To run commands with the Restate CLI, use the following command:

            ```shell
            docker run -it --network=host docker.io/restatedev/restate-cli:VAR::RESTATE_VERSION invocations ls
            ```

            Replace `invocations ls` by the CLI command you want to run.

        </TabItem>
    </Tabs>
</Step>
<Step stepLabel="2" title="Get the Greeter service template">

    Select your favorite runtime:
    <Tabs groupId={"ts-runtime"} className={"selection-button"}>
        <TabItem value={"Node.js"} label={<><img src='/img/quickstart/nodejs.svg' alt="Node.js" className="icon" />Node.js</>}>
            <CodeWithTabs>
                ```shell !!tabs CLI
                restate example typescript-hello-world &&
                cd typescript-hello-world &&
                npm install
                ```

                ```shell !!tabs npx
                npx -y @restatedev/create-app@latest && cd restate-node-template &&
                npm install
                ```
            </CodeWithTabs>

            This gives you the following template:
            ```ts src/app.ts
            CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/main/templates/typescript/src/app.ts
            ```
        </TabItem>
        <TabItem value={"Bun"} label={<><img src='/img/quickstart/bun.svg' alt="bun" className="icon" />bun</>}>
            ```shell
            restate example typescript-bun-hello-world &&
            cd typescript-bun-hello-world &&
            npm install
            ```

            This gives you the following template:
            ```ts src/index.ts
            CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/main/templates/bun/src/index.ts
            ```
        </TabItem>
        <TabItem value={"Deno"} label={<><img src='/img/quickstart/deno.svg' alt="deno" className="icon" />Deno</>}>
            ```shell
            restate example typescript-deno-hello-world &&
            cd typescript-deno-hello-world &&
            npm install
            ```

            This gives you the following template:
            ```ts deno/main.ts
            CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/main/templates/deno/main.ts
            ```
        </TabItem>
        <TabItem value={"CloudflareWorkers"} label={<><img src='/img/quickstart/cloudflare_workers.svg' alt="Cloudflare Workers" className="icon" />Cloudflare Workers</>}>
            ```shell
            restate example typescript-cloudflare-worker-hello-world &&
            cd typescript-cloudflare-worker-hello-world &&
            npm install
            ```

            This gives you the following template:
            ```ts src/index.ts
            CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/main/templates/cloudflare-worker/src/index.ts
            ```
        </TabItem>
    </Tabs>



</Step>
<Step stepLabel="3" title="Run the Greeter service">

    Run it with [`ts-node-dev`](https://www.npmjs.com/package/ts-node-dev), and let it listen on port `9080` for requests:

    <Terminal>

        ```shell !command
        npm run app-dev
        ```

        ```log !output
        > restate-ts-template@0.0.1 app-dev
        > ts-node-dev --watch ./src --respawn --transpile-only ./src/app.ts

        [INFO] 00:44:54 ts-node-dev ver. 2.0.0 (using ts-node ver. 10.9.2, typescript ver. 5.6.3)
        [restate] [2024-11-12T23:44:54.955Z] INFO:  Listening on 9080...
        [restate] [2024-11-12T23:44:54.957Z] WARN:  Accepting requests without validating request signatures; handler access must be restricted
        ```

    </Terminal>

</Step>

<Step stepLabel="4" title="Register the service">

    Tell Restate where the service is running, so Restate can discover and register the services and handlers behind this endpoint:


    <TerminalWithTabs>

        # !!terminals

        ```shell !command CLI
        restate deployments register http://localhost:9080
        ```

        ```shell !output
        ‚ùØ SERVICES THAT WILL BE ADDED:
        - Greeter
        Type: Service
        HANDLER  INPUT                                     OUTPUT
        greet    value of content-type 'application/json'  value of content-type 'application/json'


        ‚úî Are you sure you want to apply those changes? ¬∑ yes
        ‚úÖ DEPLOYMENT:
        SERVICE  REV
        Greeter  1
        ```

        # !!terminals

        ```shell !command curl
        curl localhost:9070/deployments -H 'content-type: application/json' \
        -d '{"uri": "http://localhost:9080"}'
        ```

        ```shell !output
        {
            "id": "dp_17sztQp4gnEC1L0OCFM9aEh",
            "services": [
        {
            "name": "Greeter",
            "handlers": [
        {
            "name": "greet",
            "ty": "Shared",
            "input_description": "one of [\"none\", \"value of content-type 'application/json'\"]",
            "output_description": "value of content-type 'application/json'"
        }
            ],
            "ty": "Service",
            "deployment_id": "dp_17sztQp4gnEC1L0OCFM9aEh",
            "revision": 1,
            "public": true,
            "idempotency_retention": "1day"
        }
            ]
        }

        ```

    </TerminalWithTabs>

    If you run Restate with Docker, use `http://host.docker.internal:9080` instead of `http://localhost:9080`.
</Step>

<Step stepLabel="5" title="Send a request to the Greeter service">

    <Terminal>

        ```shell !command
        curl localhost:8080/Greeter/greet -H 'content-type: application/json' -d '"Hi"'
        ```

        ```shell !output
        Hi!
        ```

    </Terminal>

</Step>
<Step end={true} stepLabel="üéâ" title="Congratulations, you now have working setup!"/>

<details className="grey-details">

    <summary>Next: Build and run the app</summary>

    Once you have implemented your service, build the app and run it with:

    ```shell
    npm run build
    npm run app
    ```

</details>

Want to understand what Restate is about? Continue reading below.

## 5-minute Exploration of Restate

The `greet` handler is a template. When you call it, it just returns the input string.
At first sight, this might look like a simple REST service. But it's much more than that.

**Restate makes code resilient against infrastructure failures, API downtime and timeouts, concurrent retries, network failures, etc.
Restate proxies requests to your service, and persists the progress the handlers make.
This way, it can make sure that requests run till completion by retrying failed requests and recovering the progress of the handler.**

Imagine we have a handler which adds a user to a subscription service by first setting up a recurring payment and then creating the subscriptions.
Below, this is one time implemented as an express app and one time as a Restate service.
Let's compare their behaviour under failures.

<div className="row">
    <div className={"col col--6 padding-right--lg"}>
        **Without Restate**

        ```ts express_app.ts
        CODE_LOAD::ts/src/get_started/express.ts
        ```
    </div>
    <div className={"col col--6 padding-left--none"}>
        **With Restate**

        ```ts restate_service.ts
        CODE_LOAD::ts/src/get_started/app.ts
        ```

    </div>
</div>

| Without Restate  | With Restate |
|-----------------|--------------|
| ‚ùå **No retries**: To make this resilient, you would have to implement retries yourself. You would need retry logic in the upstream caller of this handler, and within the handler for the payment and subscription API calls. | ‚úÖ **Built-in retries**: Restate registers incoming requests and makes sure they are retried until they run till completion. If the service itself crashes or if the API requests time out, Restate will retry the handler until it succeeds. |
| ‚ùå **No recovery of progress**: If this handler would fail halfway, we would have to implement logic to recover the progress. For example, we would need to store the payment identifier in a database to be able to retry the payment without creating a duplicate payment. We would need to make sure we don't re-execute steps we already did. | ‚úÖ **Recovery of progress**: The Restate Context \`ctx\` lets us persist actions throughout our handler. For example, the generation of the payment identifier is wrapped in \`ctx.run\`, to store it in Restate. On retries, we will now always get the same payment identifier. If the API is down or the network fails, Restate retries only the failed step without retrying the previously succeeded steps. |
| ‚ùå **No deduplication**: If the upstream caller loses the connection to the handler and retries the request, we could end up with multiple payments or subscriptions for the same user. | ‚úÖ **Idempotency for requests**: Restate lets you add an idempotency key to the header of your request. Restate will make sure each request is processed only once, and returns the previous result on retries. |

<div className="row">
    <div className={"col col--6 padding-right--lg"}>

        Imagine a flaky payment API, where half of the requests fail.
        When the express app crashes, we lose the request, payment idempotency key, and progress.
        When we retry the request, we might end up with multiple payments for the same user.

    </div>
    <div className={"col col--6 padding-left--none"}>

        Imagine a flaky payment API, where half of the requests fail.
        In the case of Restate, the request is persisted, and the payment identifier is persisted.
        Restate retries the payment until it succeeds:

    </div>
</div>

<video controls autoplay loop className="quickstart-video">
    <source src="/img/quickstart/resiliency_quickstart.mp4" type="video/mp4" />
    Your browser does not support the video tag.
</video>

<details className={"grey-details"}>

    <summary>Running the subscription service locally</summary>

You can run the Restate service yourself by copying over the code into your template, and running `npm run app-dev`.

Register the service with Restate by running `restate deployments register http://localhost:9080 --force`.
    You need to use `--force` to overwrite the existing deployment (only use this for development).

Then send a request to the service:
```shell
curl -X POST http://localhost:8080/SubscriptionService/add \
    -H "Content-Type: application/json" \
    -d '{
      "userId": "user123",
      "creditCard": "4111111111111111",
      "subscriptions": ["Netflix", "Hulu", "Disney+"]
    }'
```

</details>

## Towards Fully Resilient Applications

Restate does not only provide resiliency to executing a single handler, but also to the communication between services, and to the state of your application:

- **[Durable RPC](/develop/ts/service-communication)**: let services call each other in a resilient way
- **[Durable messaging](/develop/ts/service-communication#sending-messages)**: let services communicate via messages, without deploying a message broker. Implement async tasks, optionally with a delay.
- **Durable [promises](/develop/ts/awakeables) and [timers](/develop/ts/durable-timers)**: let services wait for external events, like webhooks or timers. Restate makes sure promises are recoverable after failures.
- **[Consistent K/V state](/develop/ts/state)**: persist application state in Restate with a simple concurrency model and no extra setup. Restate makes sure state remains consistent in case of failures.

These durable coding constructs make it very easy to implement more complex patterns.

For example, you can implement a file processing workflow with Restate.
The workflow waits for human approval, and then and processes the file in parallel.
Restate will remember which steps got executed, so that it can recover our workflow after a failure, similar to a workflow orchestrator.

<Scrollycoding>
    # !!steps
    1. **Durable messaging:** We send a notification to the employee that needs to approve this file upload.
    The effect of this is similar to publishing an event to a queue.
    Restate is the queue and makes sure the event is processed exactly once.
    You can use this to schedule async tasks, optionally with a delay.

    ```ts !
    CODE_LOAD::ts/src/get_started/app_2.ts?1
    ```

    # !!steps
    2. **Durable Promises:** We wait for the employee to confirm the upload.
    Restate will register the promise, wait for its resolution, and makes sure the promise is recoverable after a failure.

    ```ts !
    CODE_LOAD::ts/src/get_started/email_verification.ts?1
    ```
    # !!steps
    3. **Durable timers:** If no confirmation is received within 24 hours, we send a reminder to the employee.
    This is implemented with Restate's Durable Timers.
    Restate will register the timer, wait for the timer to expire, and makes sure the timer is recoverable after a failure.

    ```ts !
    CODE_LOAD::ts/src/get_started/email_verification.ts?2
    ```

</Scrollycoding>

<details className={"grey-details"}>
<summary>Running the file workflow locally</summary>

    1. Copy the full code (including stubs) into your project

    ```ts app.ts
    CODE_LOAD::ts/src/get_started/app_2.ts
    ```

    ```ts email_verification.ts
    CODE_LOAD::ts/src/get_started/email_verification.ts#full
    ```

    2. Run the service

    ```shell
    npm run app-dev
    ```

    3. Register the service with Restate. Use `force` to overwrite the existing deployment (only use this for development).
    ```shell
    restate deployments register http://localhost:9080 --force
    ```

    4. Send a request to the service:

    ```shell
    curl -X POST http://localhost:8080/SubscriptionService/add \
        -H "Content-Type: application/json" \
        -d '{
            "userId": "user123",
            "email": "user123@user.com",
            "creditCard": "4111111111111111",
            "subscriptions": ["Netflix", "Hulu", "Disney+"]
        }'
    ```

    5. Optional: The invocation will now be blocking on the promise.
    You can now use the Restate CLI to inspect the invocation and see what it is stuck on.

    First list the running invocations to find the invocation ID:

    <Terminal>
        ```shell !command
        restate inv ls
        ```
        ```shell !output
        ‚ùØ [2024-11-12 20:40:08.149 +01:00] inv_1lww6dToghwj3jShyf2z5j91EWKm6OnRgB
        Target:      FileWorkflow/23/run
        Status:      running  (4 seconds and 765 ms)
        Deployment:  dp_14DypPEJ9kZcklM7zwdBs2J [required] using
        restate-sdk-typescript/1.4.0
        ```
    </Terminal>

    Then use the invocation ID to see the progress:

    <Terminal>

    ```shell !command
    restate invocations describe inv_1lww6dToghwj3jShyf2z5j91EWKm6OnRgB
    ```

    ```shell !output
    üìú Invocation Information:
    ‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï
    Created at:   2024-11-12 20:40:08.149 +01:00 (11 seconds ago)
    Target:       FileWorkflow/23/run
    Status:       running  (11 seconds and 169 ms)
    Deployment:   dp_14DypPEJ9kZcklM7zwdBs2J [required] using
    restate-sdk-typescript/1.4.0
    Modified at:  2024-11-12 20:40:18.173 +01:00

    üí°   This invocation is bound to run on deployment 'dp_14DypPEJ9kZcklM7zwdBs2J'. To guarantee
    safety and correctness, invocations that made progress on a deployment
    cannot move to newer deployments automatically.

    üöÇ Invocation Progress:
    ‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï
    [Ingress]
    ‚îî‚îÄ‚îÄ(this)‚îÄ> FileWorkflow/23/run
    ‚ñ∏
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ ‚òëÔ∏è  #1 Send NotificationService/notify inv_1ai7U4M25kAK317XiCwqn4cbqOgb2TSjTz
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ ‚è∏Ô∏è  #2 Promise approval
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ ‚òëÔ∏è  #3 Sleep until 2024-11-12 20:40:18.159 +01:00
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ ‚òëÔ∏è  #6 Send NotificationService/remind inv_1c0ewogz3NG95fXBsEJkJrLQZkIjhxb6LL
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ ‚è∏Ô∏è  #7 Promise approval
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ ‚è∞ #8 Sleep until 2024-11-12 20:40:28.172 +01:00 (8 seconds and 768 ms left)
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ>> running
    ```
    </Terminal>

    6.  You can resolve the promise by sending a POST request to the promise endpoint:

    ```shell
    curl -X POST http://localhost:8080/FileWorkflow/file488/evaluate \
        -H "Content-Type: application/json" \
        -d 'true'
    ```

    Now the invocation will complete.

</details>


Now that you have a basic understanding of Restate, you can start building your own services.


## Next steps
- Read the [Concepts](/concepts/durable_building_blocks)
- Discover the key features of Restate in the [Tour of Restate](/get_started/tour)
- [Run the examples](https://github.com/restatedev/examples)

