{
  "$schema": "https://json-schema.org/draft/2019-09/schema",
  "title": "Restate configuration file",
  "description": "Configuration for Restate server.",
  "type": "object",
  "required": [
    "tracing-filter",
    "tracing-headers"
  ],
  "properties": {
    "worker": {
      "default": {
        "cleanup-interval": "1h",
        "experimental-feature-new-invocation-status-table": false,
        "internal-queue-length": 1000,
        "invoker": {
          "abort-timeout": "1m",
          "concurrent-invocations-limit": 100,
          "in-memory-queue-length-limit": 1056784,
          "inactivity-timeout": "1m",
          "message-size-limit": null,
          "message-size-warning": "10.0 MB",
          "retry-policy": {
            "factor": 2.0,
            "initial-interval": "50ms",
            "max-attempts": null,
            "max-interval": "10s",
            "type": "exponential"
          },
          "tmp-dir": null
        },
        "max-command-batch-size": 4,
        "num-timers-in-memory-limit": null,
        "storage": {
          "persist-lsn-interval": "1h",
          "persist-lsn-threshold": 1000,
          "rocksdb-disable-wal": true,
          "rocksdb-memory-ratio": 0.49000000953674316
        }
      },
      "$ref": "#/definitions/WorkerOptions"
    },
    "admin": {
      "default": {
        "bind-address": "0.0.0.0:9070",
        "concurrent-api-requests-limit": null,
        "default-replication-strategy": "on-all-nodes",
        "heartbeat-interval": "1s 500ms",
        "log-trim-interval": "1h",
        "log-trim-threshold": 1000,
        "query-engine": {
          "memory-size": "4.0 GB",
          "pgsql-bind-address": "0.0.0.0:9071",
          "query-parallelism": null,
          "tmp-dir": null
        }
      },
      "$ref": "#/definitions/AdminOptions"
    },
    "ingress": {
      "default": {
        "bind-address": "0.0.0.0:8080",
        "concurrent-api-requests-limit": null,
        "kafka-clusters": []
      },
      "$ref": "#/definitions/IngressOptions"
    },
    "bifrost": {
      "default": {
        "append-retry-max-interval": "1s",
        "append-retry-min-interval": "10ms",
        "default-provider": "local",
        "default-provider-config": null,
        "local": {
          "rocksdb-disable-wal": false,
          "rocksdb-disable-wal-fsync": false,
          "rocksdb-memory-ratio": 0.5,
          "writer-batch-commit-count": 5000,
          "writer-batch-commit-duration": "0s"
        },
        "read-retry-policy": {
          "factor": 2.0,
          "initial-interval": "50ms",
          "max-attempts": 50,
          "max-interval": "1s",
          "type": "exponential"
        },
        "seal-retry-interval": "2s"
      },
      "$ref": "#/definitions/BifrostOptions"
    },
    "metadata-store": {
      "default": {
        "bind-address": "0.0.0.0:5123",
        "request-queue-length": 32,
        "rocksdb": {
          "rocksdb-disable-wal": false
        },
        "rocksdb-memory-ratio": 0.009999999776482582
      },
      "$ref": "#/definitions/LocalMetadataStoreOptions"
    },
    "networking": {
      "default": {
        "connect-retry-policy": {
          "factor": 2.0,
          "initial-interval": "10ms",
          "max-attempts": 10,
          "max-interval": "500ms",
          "type": "exponential"
        },
        "handshake-timeout": "3s"
      },
      "$ref": "#/definitions/NetworkingOptions"
    },
    "log-server": {
      "default": {
        "incoming-network-queue-length": 1000,
        "rocksdb-disable-wal": false,
        "rocksdb-disable-wal-fsync": false,
        "rocksdb-memory-ratio": 0.5,
        "writer-batch-commit-count": 5000
      },
      "$ref": "#/definitions/LogServer"
    },
    "roles": {
      "description": "Defines the roles which this Restate node should run, by default the node starts with all roles.",
      "default": [
        "worker",
        "admin",
        "metadata-store"
      ],
      "type": "array",
      "items": {
        "$ref": "#/definitions/Role"
      },
      "uniqueItems": true
    },
    "node-name": {
      "title": "Node Name",
      "description": "Unique name for this node in the cluster. The node must not change unless it's started with empty local store. It defaults to the node's hostname.",
      "type": [
        "string",
        "null"
      ]
    },
    "force-node-id": {
      "description": "If set, the node insists on acquiring this node ID.",
      "type": [
        "integer",
        "null"
      ],
      "format": "uint32",
      "minimum": 0.0
    },
    "cluster-name": {
      "title": "Cluster Name",
      "description": "A unique identifier for the cluster. All nodes in the same cluster should have the same.",
      "default": "localcluster",
      "type": "string"
    },
    "allow-bootstrap": {
      "description": "If true, then a new cluster is bootstrapped. This node *must* have an admin role and a new nodes configuration will be created that includes this node.",
      "default": true,
      "type": "boolean"
    },
    "base-dir": {
      "description": "The working directory which this Restate node should use for relative paths. The default is `restate-data` under the current working directory.",
      "type": [
        "string",
        "null"
      ]
    },
    "bind-address": {
      "description": "Address to bind for the Node server. Default is `0.0.0.0:5122`",
      "default": "0.0.0.0:5122",
      "type": "string"
    },
    "advertised-address": {
      "description": "Address that other nodes will use to connect to this node. Default is `http://127.0.0.1:5122/`",
      "default": "http://127.0.0.1:5122/",
      "type": "string"
    },
    "bootstrap-num-partitions": {
      "title": "Partitions",
      "description": "Number of partitions that will be provisioned during cluster bootstrap, partitions used to process messages.\n\nNOTE: This config entry only impacts the initial number of partitions, the value of this entry is ignored for bootstrapped nodes/clusters.\n\nCannot be higher than `65535` (You should almost never need as many partitions anyway)",
      "default": 24,
      "type": "integer",
      "format": "uint16",
      "minimum": 1.0
    },
    "shutdown-timeout": {
      "title": "Shutdown grace timeout",
      "description": "This timeout is used when shutting down the various Restate components to drain all the internal queues.\n\nCan be configured using the [`humantime`](https://docs.rs/humantime/latest/humantime/fn.parse_duration.html) format.",
      "default": "1m",
      "type": "string"
    },
    "default-thread-pool-size": {
      "title": "Default async runtime thread pool",
      "description": "Size of the default thread pool used to perform internal tasks. If not set, it defaults to the number of CPU cores.",
      "type": [
        "integer",
        "null"
      ],
      "format": "uint",
      "minimum": 0.0
    },
    "log-filter": {
      "title": "Logging Filter",
      "description": "Log filter configuration. Can be overridden by the `RUST_LOG` environment variable. Check the [`RUST_LOG` documentation](https://docs.rs/tracing-subscriber/latest/tracing_subscriber/filter/struct.EnvFilter.html) for more details how to configure it.",
      "default": "warn,restate=info",
      "type": "string"
    },
    "log-format": {
      "title": "Logging format",
      "description": "Format to use when logging.",
      "default": "pretty",
      "$ref": "#/definitions/LogFormat"
    },
    "log-disable-ansi-codes": {
      "title": "Disable ANSI in log output",
      "description": "Disable ANSI terminal codes for logs. This is useful when the log collector doesn't support processing ANSI terminal codes.",
      "default": false,
      "type": "boolean"
    },
    "histogram-inactivity-timeout": {
      "description": "Timeout for idle histograms.\n\nThe duration after which a histogram is considered idle and will be removed from metric responses to save memory. Unsetting means that histograms will never be removed.",
      "type": [
        "string",
        "null"
      ]
    },
    "disable-prometheus": {
      "description": "Disable prometheus metric recording and reporting. Default is `false`.",
      "default": false,
      "type": "boolean"
    },
    "storage-high-priority-bg-threads": {
      "description": "Storage high priority thread pool\n\nThis configures the restate-managed storage thread pool for performing high-priority or latency-sensitive storage tasks when the IO operation cannot be performed on in-memory caches.",
      "type": [
        "integer",
        "null"
      ],
      "format": "uint",
      "minimum": 1.0
    },
    "storage-low-priority-bg-threads": {
      "description": "Storage low priority thread pool\n\nThis configures the restate-managed storage thread pool for performing low-priority or latency-insensitive storage tasks.",
      "type": [
        "integer",
        "null"
      ],
      "format": "uint",
      "minimum": 1.0
    },
    "rocksdb-total-memory-size": {
      "title": "Total memory limit for rocksdb caches and memtables.",
      "description": "This includes memory for uncompressed block cache and all memtables by all open databases. The memory size used for rocksdb caches.",
      "default": "6.0 GB",
      "$ref": "#/definitions/NonZeroHumanBytes"
    },
    "rocksdb-total-memtables-ratio": {
      "title": "Rocksdb total memtable size ratio",
      "description": "The memory size used across all memtables (ratio between 0 to 1.0). This limits how much memory memtables can eat up from the value in rocksdb-total-memory-limit. When set to 0, memtables can take all available memory up to the value specified in rocksdb-total-memory-limit. This value will be sanitized to 1.0 if outside the valid bounds.",
      "default": 0.5,
      "type": "number",
      "format": "float"
    },
    "rocksdb-bg-threads": {
      "title": "Rocksdb Background Threads",
      "description": "The number of threads to reserve to Rocksdb background tasks. Defaults to the number of cores on the machine.",
      "type": [
        "integer",
        "null"
      ],
      "format": "uint32",
      "minimum": 1.0
    },
    "rocksdb-high-priority-bg-threads": {
      "title": "Rocksdb High Priority Background Threads",
      "description": "The number of threads to reserve to high priority Rocksdb background tasks.",
      "default": 2,
      "type": "integer",
      "format": "uint32",
      "minimum": 1.0
    },
    "rocksdb-write-stall-threshold": {
      "title": "Rocksdb stall detection threshold",
      "description": "This defines the duration afterwhich a write is to be considered in \"stall\" state. For every write that meets this threshold, the system will increment the `restate.rocksdb_stall_flare` gauge, if the write is unstalled, the guage will be updated accordingly.",
      "default": "3s",
      "type": "string"
    },
    "rocksdb-enable-stall-on-memory-limit": {
      "title": "Allow rocksdb writes to stall if memory limit is reached",
      "description": "Note if automatic memory budgeting is enabled, it should be safe to allow rocksdb to stall if it hits the limit. However, if rocksdb stall kicked in, it's unlikely that the system will recover from this without intervention.",
      "default": false,
      "type": "boolean"
    },
    "rocksdb-perf-level": {
      "title": "Rocksdb performance statistics level",
      "description": "Defines the level of PerfContext used internally by rocksdb. Default is `enable-count` which should be sufficient for most users. Note that higher levels incur a CPU cost and might slow down the critical path.",
      "default": "enable-count",
      "$ref": "#/definitions/RocksbPerfStatisticsLevel"
    },
    "metadata-update-interval": {
      "title": "Metadata update interval",
      "description": "The interval at which each node checks for metadata updates it has observed from different nodes or other sources.",
      "default": "3s",
      "type": "string"
    },
    "network-error-retry-policy": {
      "title": "Network error retry policy",
      "description": "The retry policy for node network error",
      "default": {
        "factor": 2.0,
        "initial-interval": "10ms",
        "max-attempts": 15,
        "max-interval": "5s",
        "type": "exponential"
      },
      "$ref": "#/definitions/RetryPolicy"
    },
    "metadata-store-client": {
      "description": "Metadata store server to bootstrap the node from.",
      "default": {
        "address": "http://127.0.0.1:5123/",
        "type": "embedded"
      },
      "$ref": "#/definitions/MetadataStoreClient"
    },
    "metadata-store-client-backoff-policy": {
      "title": "Backoff policy used by the metadata store client",
      "description": "Backoff policy used by the metadata store client when it encounters concurrent modifications.",
      "default": {
        "factor": 2.0,
        "initial-interval": "10ms",
        "max-attempts": null,
        "max-interval": "100ms",
        "type": "exponential"
      },
      "$ref": "#/definitions/RetryPolicy"
    },
    "tracing-endpoint": {
      "title": "Tracing Endpoint",
      "description": "Specify the tracing endpoint to send traces to. Traces will be exported using [OTLP gRPC](https://opentelemetry.io/docs/specs/otlp/#otlpgrpc) through [opentelemetry_otlp](https://docs.rs/opentelemetry-otlp/0.12.0/opentelemetry_otlp/).\n\nTo configure the sampling, please refer to the [opentelemetry autoconfigure docs](https://github.com/open-telemetry/opentelemetry-java/blob/main/sdk-extensions/autoconfigure/README.md#sampler).",
      "type": [
        "string",
        "null"
      ]
    },
    "tracing-json-path": {
      "title": "Distributed Tracing JSON Export Path",
      "description": "If set, an exporter will be configured to write traces to files using the Jaeger JSON format. Each trace file will start with the `trace` prefix.\n\nIf unset, no traces will be written to file.\n\nIt can be used to export traces in a structured format without configuring a Jaeger agent.\n\nTo inspect the traces, open the Jaeger UI and use the Upload JSON feature to load and inspect them.",
      "type": [
        "string",
        "null"
      ]
    },
    "tracing-filter": {
      "title": "Tracing Filter",
      "description": "Distributed tracing exporter filter. Check the [`RUST_LOG` documentation](https://docs.rs/tracing-subscriber/latest/tracing_subscriber/filter/struct.EnvFilter.html) for more details how to configure it.",
      "type": "string"
    },
    "tracing-headers": {
      "title": "Additional tracing headers",
      "description": "Specify additional headers you want the system to send to the tracing endpoint (e.g. authentication headers).",
      "type": "object",
      "additionalProperties": {
        "type": "string"
      }
    },
    "request-identity-private-key-pem-file": {
      "title": "Request identity private key PEM file",
      "description": "A path to a file, such as \"/var/secrets/key.pem\", which contains exactly one ed25519 private key in PEM format. Such a file can be generated with `openssl genpkey -algorithm ed25519`. If provided, this key will be used to attach JWTs to requests from this client which SDKs may optionally verify, proving that the caller is a particular Restate instance.\n\nThis file is currently only read on client creation, but this may change in future. Parsed public keys will be logged at INFO level in the same format that SDKs expect.",
      "type": [
        "string",
        "null"
      ]
    },
    "http-keep-alive-options": {
      "title": "HTTP/2 Keep-alive",
      "description": "Configuration for the HTTP/2 keep-alive mechanism, using PING frames. If unset, HTTP/2 keep-alive are disabled.",
      "default": {
        "interval": "40s",
        "timeout": "20s"
      },
      "$ref": "#/definitions/Http2KeepAliveOptions"
    },
    "http-proxy": {
      "title": "Proxy URI",
      "description": "A URI, such as `http://127.0.0.1:10001`, of a server to which all invocations should be sent, with the `Host` header set to the deployment URI. HTTPS proxy URIs are supported, but only HTTP endpoint traffic will be proxied currently. Can be overridden by the `HTTP_PROXY` environment variable.",
      "type": [
        "string",
        "null"
      ]
    },
    "connect-timeout": {
      "title": "Connect timeout",
      "description": "How long to wait for a TCP connection to be established before considering it a failed attempt.",
      "default": "10s",
      "type": "string"
    },
    "aws-profile": {
      "title": "AWS Profile",
      "description": "Name of the AWS profile to select. Defaults to 'AWS_PROFILE' env var, or otherwise the `default` profile.",
      "type": [
        "string",
        "null"
      ]
    },
    "aws-assume-role-external-id": {
      "title": "AssumeRole external ID",
      "description": "An external ID to apply to any AssumeRole operations taken by this client. https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html Can be overridden by the `AWS_EXTERNAL_ID` environment variable.",
      "type": [
        "string",
        "null"
      ]
    },
    "rocksdb-disable-direct-io-for-reads": {
      "title": "Disable Direct IO for reads",
      "description": "Files will be opened in \"direct I/O\" mode which means that data r/w from the disk will not be cached or buffered. The hardware buffer of the devices may however still be used. Memory mapped files are not impacted by these parameters.",
      "type": [
        "boolean",
        "null"
      ]
    },
    "rocksdb-disable-direct-io-for-flush-and-compactions": {
      "title": "Disable Direct IO for flush and compactions",
      "description": "Use O_DIRECT for writes in background flush and compactions.",
      "type": [
        "boolean",
        "null"
      ]
    },
    "rocksdb-disable-wal": {
      "title": "Disable WAL",
      "description": "The default depends on the different rocksdb use-cases at Restate.\n\nSupports hot-reloading (Partial / Bifrost only)",
      "type": [
        "boolean",
        "null"
      ]
    },
    "rocksdb-disable-statistics": {
      "description": "Disable rocksdb statistics collection\n\nDefault: False (statistics enabled)",
      "type": [
        "boolean",
        "null"
      ]
    },
    "rocksdb-max-background-jobs": {
      "title": "RocksDB max background jobs (flushes and compactions)",
      "description": "Default: the number of CPU cores on this node.",
      "type": [
        "integer",
        "null"
      ],
      "format": "uint32",
      "minimum": 1.0
    },
    "rocksdb-compaction-readahead-size": {
      "title": "RocksDB compaction readahead size in bytes",
      "description": "If non-zero, we perform bigger reads when doing compaction. If you're running RocksDB on spinning disks, you should set this to at least 2MB. That way RocksDB's compaction is doing sequential instead of random reads.",
      "anyOf": [
        {
          "$ref": "#/definitions/NonZeroHumanBytes"
        },
        {
          "type": "null"
        }
      ]
    },
    "rocksdb-statistics-level": {
      "title": "RocksDB statistics level",
      "description": "StatsLevel can be used to reduce statistics overhead by skipping certain types of stats in the stats collection process.\n\nDefault: \"except-detailed-timers\"",
      "anyOf": [
        {
          "$ref": "#/definitions/RocksbStatistics"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "definitions": {
    "WorkerOptions": {
      "title": "Worker options",
      "type": "object",
      "properties": {
        "internal-queue-length": {
          "title": "Internal queue for partition processor communication",
          "default": 1000,
          "type": "integer",
          "format": "uint",
          "minimum": 1.0
        },
        "num-timers-in-memory-limit": {
          "title": "Num timers in memory limit",
          "description": "The number of timers in memory limit is used to bound the amount of timers loaded in memory. If this limit is set, when exceeding it, the timers farther in the future will be spilled to disk.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint",
          "minimum": 1.0
        },
        "cleanup-interval": {
          "title": "Cleanup interval",
          "description": "In order to clean up completed invocations, that is invocations invoked with an idempotency id, or workflows, Restate periodically scans among the completed invocations to check whether they need to be removed or not. This interval sets the scan interval of the cleanup procedure. Default: 1 hour.\n\nCan be configured using the [`humantime`](https://docs.rs/humantime/latest/humantime/fn.parse_duration.html) format.",
          "default": "1h",
          "type": "string"
        },
        "storage": {
          "default": {
            "persist-lsn-interval": "1h",
            "persist-lsn-threshold": 1000,
            "rocksdb-disable-wal": true,
            "rocksdb-memory-ratio": 0.49000000953674316
          },
          "$ref": "#/definitions/StorageOptions"
        },
        "invoker": {
          "default": {
            "abort-timeout": "1m",
            "concurrent-invocations-limit": 100,
            "in-memory-queue-length-limit": 1056784,
            "inactivity-timeout": "1m",
            "message-size-limit": null,
            "message-size-warning": "10.0 MB",
            "retry-policy": {
              "factor": 2.0,
              "initial-interval": "50ms",
              "max-attempts": null,
              "max-interval": "10s",
              "type": "exponential"
            },
            "tmp-dir": null
          },
          "$ref": "#/definitions/InvokerOptions"
        },
        "max-command-batch-size": {
          "title": "Maximum command batch size for partition processors",
          "description": "The maximum number of commands a partition processor will apply in a batch. The larger this value is, the higher the throughput and latency are.",
          "default": 4,
          "type": "integer",
          "format": "uint",
          "minimum": 1.0
        }
      }
    },
    "StorageOptions": {
      "title": "Storage options",
      "type": "object",
      "properties": {
        "num-partitions-to-share-memory-budget": {
          "description": "How many partitions to divide memory across?\n\nBy default this uses the value defined in `bootstrap-num-partitions` in the common section of the config.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint16",
          "minimum": 1.0
        },
        "rocksdb-memory-budget": {
          "description": "The memory budget for rocksdb memtables in bytes\n\nThe total is divided evenly across partitions. The divisor is defined in `num-partitions-to-share-memory-budget`. If this value is set, it overrides the ratio defined in `rocksdb-memory-ratio`.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonZeroHumanBytes"
            },
            {
              "type": "null"
            }
          ]
        },
        "rocksdb-memory-ratio": {
          "description": "The memory budget for rocksdb memtables as ratio\n\nThis defines the total memory for rocksdb as a ratio of all memory available to memtables (See `rocksdb-total-memtables-ratio` in common). The budget is then divided evenly across partitions. The divisor is defined in `num-partitions-to-share-memory-budget`",
          "default": 0.49000000953674316,
          "type": "number",
          "format": "float"
        },
        "persist-lsn-interval": {
          "title": "Persist lsn interval",
          "description": "Controls the interval at which worker tries to persist the last applied lsn. Lsn persisting can be disabled by setting it to \"\".",
          "default": "1h",
          "type": [
            "string",
            "null"
          ]
        },
        "persist-lsn-threshold": {
          "title": "Persist lsn threshold",
          "description": "Minimum number of applied log entries before persisting the lsn. The worker will only persist a lsn if the partition processor has applied at least #threshold log entries since the last persisting. This prevents the worker from flushing the RocksDB memtables too often.",
          "default": 1000,
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "rocksdb-disable-direct-io-for-reads": {
          "title": "Disable Direct IO for reads",
          "description": "Files will be opened in \"direct I/O\" mode which means that data r/w from the disk will not be cached or buffered. The hardware buffer of the devices may however still be used. Memory mapped files are not impacted by these parameters.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-disable-direct-io-for-flush-and-compactions": {
          "title": "Disable Direct IO for flush and compactions",
          "description": "Use O_DIRECT for writes in background flush and compactions.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-disable-wal": {
          "title": "Disable WAL",
          "description": "The default depends on the different rocksdb use-cases at Restate.\n\nSupports hot-reloading (Partial / Bifrost only)",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-disable-statistics": {
          "description": "Disable rocksdb statistics collection\n\nDefault: False (statistics enabled)",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-max-background-jobs": {
          "title": "RocksDB max background jobs (flushes and compactions)",
          "description": "Default: the number of CPU cores on this node.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 1.0
        },
        "rocksdb-compaction-readahead-size": {
          "title": "RocksDB compaction readahead size in bytes",
          "description": "If non-zero, we perform bigger reads when doing compaction. If you're running RocksDB on spinning disks, you should set this to at least 2MB. That way RocksDB's compaction is doing sequential instead of random reads.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonZeroHumanBytes"
            },
            {
              "type": "null"
            }
          ]
        },
        "rocksdb-statistics-level": {
          "title": "RocksDB statistics level",
          "description": "StatsLevel can be used to reduce statistics overhead by skipping certain types of stats in the stats collection process.\n\nDefault: \"except-detailed-timers\"",
          "anyOf": [
            {
              "$ref": "#/definitions/RocksbStatistics"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "NonZeroHumanBytes": {
      "title": "Non-zero human-readable bytes",
      "description": "Non-zero human-readable bytes",
      "type": "string",
      "format": "non-zero human-bytes",
      "minimum": 1.0,
      "minLength": 1,
      "pattern": "^\\d+(\\.\\d+)? ?[KMG]B$"
    },
    "RocksbStatistics": {
      "oneOf": [
        {
          "description": "Disable all metrics",
          "type": "string",
          "enum": [
            "disable-all"
          ]
        },
        {
          "description": "Disable timer stats, and skip histogram stats",
          "type": "string",
          "enum": [
            "except-histogram-or-timers"
          ]
        },
        {
          "description": "Skip timer stats",
          "type": "string",
          "enum": [
            "except-timers"
          ]
        },
        {
          "description": "Collect all stats except time inside mutex lock AND time spent on compression.",
          "type": "string",
          "enum": [
            "except-detailed-timers"
          ]
        },
        {
          "description": "Collect all stats except the counters requiring to get time inside the mutex lock.",
          "type": "string",
          "enum": [
            "except-time-for-mutex"
          ]
        },
        {
          "description": "Collect all stats, including measuring duration of mutex operations. If getting time is expensive on the platform to run, it can reduce scalability to more threads, especially for writes.",
          "type": "string",
          "enum": [
            "all"
          ]
        }
      ]
    },
    "InvokerOptions": {
      "title": "Invoker options",
      "type": "object",
      "properties": {
        "retry-policy": {
          "title": "Retry policy",
          "description": "Retry policy to use for all the invocations handled by this invoker.",
          "default": {
            "factor": 2.0,
            "initial-interval": "50ms",
            "max-attempts": null,
            "max-interval": "10s",
            "type": "exponential"
          },
          "$ref": "#/definitions/RetryPolicy"
        },
        "inactivity-timeout": {
          "title": "Inactivity timeout",
          "description": "This timer guards against stalled service/handler invocations. Once it expires, Restate triggers a graceful termination by asking the service invocation to suspend (which preserves intermediate progress).\n\nThe 'abort timeout' is used to abort the invocation, in case it doesn't react to the request to suspend.\n\nCan be configured using the [`humantime`](https://docs.rs/humantime/latest/humantime/fn.parse_duration.html) format.",
          "default": "1m",
          "type": "string"
        },
        "abort-timeout": {
          "title": "Abort timeout",
          "description": "This timer guards against stalled service/handler invocations that are supposed to terminate. The abort timeout is started after the 'inactivity timeout' has expired and the service/handler invocation has been asked to gracefully terminate. Once the timer expires, it will abort the service/handler invocation.\n\nThis timer potentially **interrupts** user code. If the user code needs longer to gracefully terminate, then this value needs to be set accordingly.\n\nCan be configured using the [`humantime`](https://docs.rs/humantime/latest/humantime/fn.parse_duration.html) format.",
          "default": "1m",
          "type": "string"
        },
        "message-size-warning": {
          "title": "Message size warning",
          "description": "Threshold to log a warning in case protocol messages coming from a service are larger than the specified amount.",
          "default": "10.0 MB",
          "$ref": "#/definitions/NonZeroHumanBytes"
        },
        "message-size-limit": {
          "title": "Message size limit",
          "description": "Threshold to fail the invocation in case protocol messages coming from a service are larger than the specified amount.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonZeroHumanBytes"
            },
            {
              "type": "null"
            }
          ]
        },
        "tmp-dir": {
          "title": "Temporary directory",
          "description": "Temporary directory to use for the invoker temporary files. If empty, the system temporary directory will be used instead.",
          "type": [
            "string",
            "null"
          ]
        },
        "in-memory-queue-length-limit": {
          "title": "Spill invocations to disk",
          "description": "Defines the threshold after which queues invocations will spill to disk at the path defined in `tmp-dir`. In other words, this is the number of invocations that can be kept in memory before spilling to disk.",
          "default": 1056784,
          "type": "integer",
          "format": "uint",
          "minimum": 1.0
        },
        "concurrent-invocations-limit": {
          "title": "Limit number of concurrent invocations from this node",
          "description": "Number of concurrent invocations that can be processed by the invoker.",
          "default": 100,
          "type": [
            "integer",
            "null"
          ],
          "format": "uint",
          "minimum": 1.0
        }
      }
    },
    "RetryPolicy": {
      "title": "Retry policy",
      "description": "Definition of a retry policy",
      "oneOf": [
        {
          "title": "None",
          "description": "No retry strategy.",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "none"
              ]
            }
          }
        },
        {
          "title": "Fixed delay",
          "description": "Retry with a fixed delay strategy.",
          "type": "object",
          "required": [
            "interval",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "fixed-delay"
              ]
            },
            "interval": {
              "title": "Interval",
              "description": "Interval between retries.\n\nCan be configured using the [`humantime`](https://docs.rs/humantime/latest/humantime/fn.parse_duration.html) format.",
              "type": "string"
            },
            "max_attempts": {
              "title": "Max attempts",
              "description": "Number of maximum attempts before giving up. Infinite retries if unset.",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint",
              "minimum": 1.0
            }
          }
        },
        {
          "title": "Exponential",
          "description": "Retry with an exponential strategy. The next retry is computed as `min(last_retry_interval * factor, max_interval)`.",
          "type": "object",
          "required": [
            "factor",
            "initial_interval",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "exponential"
              ]
            },
            "initial_interval": {
              "title": "Initial Interval",
              "description": "Initial interval for the first retry attempt.\n\nCan be configured using the [`humantime`](https://docs.rs/humantime/latest/humantime/fn.parse_duration.html) format.",
              "type": "string"
            },
            "factor": {
              "title": "Factor",
              "description": "The factor to use to compute the next retry attempt.",
              "type": "number",
              "format": "float"
            },
            "max_attempts": {
              "title": "Max attempts",
              "description": "Number of maximum attempts before giving up. Infinite retries if unset.",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint",
              "minimum": 1.0
            },
            "max_interval": {
              "title": "Max interval",
              "description": "Maximum interval between retries.",
              "type": [
                "string",
                "null"
              ]
            }
          }
        }
      ]
    },
    "AdminOptions": {
      "title": "Admin server options",
      "type": "object",
      "properties": {
        "bind-address": {
          "title": "Endpoint address",
          "description": "Address to bind for the Admin APIs.",
          "default": "0.0.0.0:9070",
          "type": "string"
        },
        "concurrent-api-requests-limit": {
          "title": "Concurrency limit",
          "description": "Concurrency limit for the Admin APIs. Default is unlimited.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint",
          "minimum": 1.0
        },
        "query-engine": {
          "default": {
            "memory-size": "4.0 GB",
            "pgsql-bind-address": "0.0.0.0:9071",
            "query-parallelism": null,
            "tmp-dir": null
          },
          "$ref": "#/definitions/QueryEngineOptions"
        },
        "heartbeat-interval": {
          "title": "Controller heartbeats",
          "description": "Controls the interval at which cluster controller polls nodes of the cluster.",
          "default": "1s 500ms",
          "type": "string"
        },
        "log-trim-interval": {
          "title": "Log trim interval",
          "description": "Controls the interval at which cluster controller tries to trim the logs. Log trimming can be disabled by setting it to \"\".",
          "default": "1h",
          "type": [
            "string",
            "null"
          ]
        },
        "log-trim-threshold": {
          "title": "Log trim threshold",
          "description": "Minimum number of trimmable log entries. The cluster controller will only trim a log if it can remove equal or more entries than this threshold. This prevents too many small trim operations.",
          "default": 1000,
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "default-replication-strategy": {
          "title": "Default replication strategy",
          "description": "The default replication strategy to be used by the cluster controller to schedule partition processors.",
          "default": "on-all-nodes",
          "$ref": "#/definitions/ReplicationStrategy"
        }
      }
    },
    "QueryEngineOptions": {
      "title": "Storage query engine options",
      "type": "object",
      "properties": {
        "memory-size": {
          "title": "Memory size limit",
          "description": "The total memory in bytes that can be used to preform sql queries",
          "default": "4.0 GB",
          "$ref": "#/definitions/NonZeroHumanBytes"
        },
        "tmp-dir": {
          "title": "Temp folder to use for spill",
          "description": "The path to spill to",
          "type": [
            "string",
            "null"
          ]
        },
        "query-parallelism": {
          "title": "Default query parallelism",
          "description": "The number of parallel partitions to use for a query execution",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint",
          "minimum": 1.0
        },
        "pgsql-bind-address": {
          "title": "Pgsql Bind address",
          "description": "The address to bind for the psql service.",
          "default": "0.0.0.0:9071",
          "type": "string"
        }
      }
    },
    "ReplicationStrategy": {
      "description": "Replication strategy for partition processors.",
      "oneOf": [
        {
          "description": "Schedule partition processor replicas on all available nodes",
          "type": "string",
          "enum": [
            "on-all-nodes"
          ]
        },
        {
          "description": "Schedule this number of partition processor replicas",
          "type": "object",
          "required": [
            "factor"
          ],
          "properties": {
            "factor": {
              "type": "integer",
              "format": "uint32",
              "minimum": 1.0
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "IngressOptions": {
      "title": "Ingress options",
      "type": "object",
      "properties": {
        "bind-address": {
          "title": "Bind address",
          "description": "The address to bind for the ingress.",
          "default": "0.0.0.0:8080",
          "type": "string"
        },
        "concurrent-api-requests-limit": {
          "title": "Concurrency limit",
          "description": "Local concurrency limit to use to limit the amount of concurrent requests. If exceeded, the ingress will reply immediately with an appropriate status code. Default is unlimited.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint",
          "minimum": 1.0
        },
        "kafka-clusters": {
          "default": [],
          "type": "array",
          "items": {
            "$ref": "#/definitions/KafkaClusterOptions"
          }
        }
      }
    },
    "KafkaClusterOptions": {
      "title": "Kafka cluster options",
      "description": "Configuration options to connect to a Kafka cluster.",
      "type": "object",
      "required": [
        "brokers",
        "name"
      ],
      "properties": {
        "name": {
          "description": "Cluster name (Used to identify subscriptions).",
          "type": "string"
        },
        "brokers": {
          "title": "Servers",
          "description": "Initial list of brokers (host or host:port).",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "BifrostOptions": {
      "title": "Bifrost options",
      "type": "object",
      "properties": {
        "default-provider": {
          "title": "The default kind of loglet to be used",
          "default": "local",
          "$ref": "#/definitions/ProviderKind"
        },
        "default-provider-config": {
          "description": "An opaque string that gets passed to the loglet provider to seed the creation of new loglets.",
          "type": [
            "string",
            "null"
          ]
        },
        "local": {
          "description": "Configuration of local loglet provider",
          "default": {
            "rocksdb-disable-wal": false,
            "rocksdb-disable-wal-fsync": false,
            "rocksdb-memory-ratio": 0.5,
            "writer-batch-commit-count": 5000,
            "writer-batch-commit-duration": "0s"
          },
          "type": "string"
        },
        "read-retry-policy": {
          "title": "Read retry policy",
          "description": "Retry policy to use when bifrost waits for reconfiguration to complete during read operations",
          "default": {
            "factor": 2.0,
            "initial-interval": "50ms",
            "max-attempts": 50,
            "max-interval": "1s",
            "type": "exponential"
          },
          "$ref": "#/definitions/RetryPolicy"
        },
        "seal-retry-interval": {
          "title": "Seal retry interval",
          "description": "Interval to wait between retries of loglet seal failures",
          "default": "2s",
          "type": "string"
        },
        "append-retry-min-interval": {
          "title": "Append retry minimum interval",
          "description": "Minimum retry duration used by the exponential backoff mechanism for bifrost appends.",
          "default": "10ms",
          "type": "string"
        },
        "append-retry-max-interval": {
          "title": "Append retry maximum interval",
          "description": "Maximum retry duration used by the exponential backoff mechanism for bifrost appends.",
          "default": "1s",
          "type": "string"
        }
      }
    },
    "ProviderKind": {
      "description": "An enum with the list of supported loglet providers.",
      "oneOf": [
        {
          "description": "A local rocksdb-backed loglet.",
          "type": "string",
          "enum": [
            "local"
          ]
        },
        {
          "description": "An in-memory loglet, primarily for testing.",
          "type": "string",
          "enum": [
            "in-memory"
          ]
        }
      ]
    },
    "LocalMetadataStoreOptions": {
      "title": "Metadata store options",
      "type": "object",
      "properties": {
        "bind-address": {
          "title": "Bind address of the metadata store",
          "description": "Address to which the metadata store will bind to.",
          "default": "0.0.0.0:5123",
          "type": "string"
        },
        "request-queue-length": {
          "title": "Limit number of in-flight requests",
          "description": "Number of in-flight metadata store requests.",
          "default": 32,
          "type": "integer",
          "format": "uint",
          "minimum": 1.0
        },
        "rocksdb-memory-budget": {
          "description": "The memory budget for rocksdb memtables in bytes\n\nIf this value is set, it overrides the ratio defined in `rocksdb-memory-ratio`.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonZeroHumanBytes"
            },
            {
              "type": "null"
            }
          ]
        },
        "rocksdb-memory-ratio": {
          "description": "The memory budget for rocksdb memtables as ratio\n\nThis defines the total memory for rocksdb as a ratio of all memory available to memtables (See `rocksdb-total-memtables-ratio` in common).",
          "default": 0.009999999776482582,
          "type": "number",
          "format": "float"
        },
        "rocksdb": {
          "title": "RocksDB options for metadata store's RocksDB instance",
          "description": "The RocksDB options which will be used to configure the metadata store's RocksDB instance.",
          "default": {
            "rocksdb-disable-wal": false
          },
          "$ref": "#/definitions/RocksDbOptions"
        }
      }
    },
    "RocksDbOptions": {
      "type": "object",
      "properties": {
        "rocksdb-disable-direct-io-for-reads": {
          "title": "Disable Direct IO for reads",
          "description": "Files will be opened in \"direct I/O\" mode which means that data r/w from the disk will not be cached or buffered. The hardware buffer of the devices may however still be used. Memory mapped files are not impacted by these parameters.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-disable-direct-io-for-flush-and-compactions": {
          "title": "Disable Direct IO for flush and compactions",
          "description": "Use O_DIRECT for writes in background flush and compactions.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-disable-wal": {
          "title": "Disable WAL",
          "description": "The default depends on the different rocksdb use-cases at Restate.\n\nSupports hot-reloading (Partial / Bifrost only)",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-disable-statistics": {
          "description": "Disable rocksdb statistics collection\n\nDefault: False (statistics enabled)",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-max-background-jobs": {
          "title": "RocksDB max background jobs (flushes and compactions)",
          "description": "Default: the number of CPU cores on this node.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 1.0
        },
        "rocksdb-compaction-readahead-size": {
          "title": "RocksDB compaction readahead size in bytes",
          "description": "If non-zero, we perform bigger reads when doing compaction. If you're running RocksDB on spinning disks, you should set this to at least 2MB. That way RocksDB's compaction is doing sequential instead of random reads.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonZeroHumanBytes"
            },
            {
              "type": "null"
            }
          ]
        },
        "rocksdb-statistics-level": {
          "title": "RocksDB statistics level",
          "description": "StatsLevel can be used to reduce statistics overhead by skipping certain types of stats in the stats collection process.\n\nDefault: \"except-detailed-timers\"",
          "anyOf": [
            {
              "$ref": "#/definitions/RocksbStatistics"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "NetworkingOptions": {
      "title": "Networking options",
      "type": "object",
      "properties": {
        "connect-retry-policy": {
          "title": "Retry policy",
          "description": "Retry policy to use for internal node-to-node networking.",
          "default": {
            "factor": 2.0,
            "initial-interval": "10ms",
            "max-attempts": 10,
            "max-interval": "500ms",
            "type": "exponential"
          },
          "$ref": "#/definitions/RetryPolicy"
        },
        "handshake-timeout": {
          "title": "Handshake timeout",
          "description": "Timeout for handshake message for internal node-to-node networking.",
          "default": "3s",
          "type": "string"
        }
      }
    },
    "LogServer": {
      "title": "Log server options",
      "description": "Configuration is only used on nodes running with `log-server` role.",
      "type": "object",
      "properties": {
        "rocksdb-memory-budget": {
          "description": "The memory budget for rocksdb memtables in bytes\n\nIf this value is set, it overrides the ratio defined in `rocksdb-memory-ratio`.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonZeroHumanBytes"
            },
            {
              "type": "null"
            }
          ]
        },
        "rocksdb-memory-ratio": {
          "description": "The memory budget for rocksdb memtables as ratio\n\nThis defines the total memory for rocksdb as a ratio of all memory available to the log-server.\n\n(See `rocksdb-total-memtables-ratio` in common).",
          "default": 0.5,
          "type": "number",
          "format": "float"
        },
        "rocksdb-disable-wal-fsync": {
          "description": "Disable fsync of WAL on every batch",
          "default": false,
          "type": "boolean"
        },
        "writer-batch-commit-count": {
          "description": "Trigger a commit when the batch size exceeds this threshold.\n\nSet to 0 or 1 to commit the write batch on every command.",
          "default": 5000,
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        },
        "incoming-network-queue-length": {
          "description": "The number of messages that can queue up on input network stream while request processor is busy.",
          "default": 1000,
          "type": "integer",
          "format": "uint",
          "minimum": 1.0
        },
        "rocksdb-disable-direct-io-for-reads": {
          "title": "Disable Direct IO for reads",
          "description": "Files will be opened in \"direct I/O\" mode which means that data r/w from the disk will not be cached or buffered. The hardware buffer of the devices may however still be used. Memory mapped files are not impacted by these parameters.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-disable-direct-io-for-flush-and-compactions": {
          "title": "Disable Direct IO for flush and compactions",
          "description": "Use O_DIRECT for writes in background flush and compactions.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-disable-wal": {
          "title": "Disable WAL",
          "description": "The default depends on the different rocksdb use-cases at Restate.\n\nSupports hot-reloading (Partial / Bifrost only)",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-disable-statistics": {
          "description": "Disable rocksdb statistics collection\n\nDefault: False (statistics enabled)",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-max-background-jobs": {
          "title": "RocksDB max background jobs (flushes and compactions)",
          "description": "Default: the number of CPU cores on this node.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 1.0
        },
        "rocksdb-compaction-readahead-size": {
          "title": "RocksDB compaction readahead size in bytes",
          "description": "If non-zero, we perform bigger reads when doing compaction. If you're running RocksDB on spinning disks, you should set this to at least 2MB. That way RocksDB's compaction is doing sequential instead of random reads.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonZeroHumanBytes"
            },
            {
              "type": "null"
            }
          ]
        },
        "rocksdb-statistics-level": {
          "title": "RocksDB statistics level",
          "description": "StatsLevel can be used to reduce statistics overhead by skipping certain types of stats in the stats collection process.\n\nDefault: \"except-detailed-timers\"",
          "anyOf": [
            {
              "$ref": "#/definitions/RocksbStatistics"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "Role": {
      "oneOf": [
        {
          "description": "A worker runs partition processor (journal, state, and drives invocations)",
          "type": "string",
          "enum": [
            "worker"
          ]
        },
        {
          "description": "Admin runs cluster controller and user-facing admin APIs",
          "type": "string",
          "enum": [
            "admin"
          ]
        },
        {
          "description": "Serves the metadata store",
          "type": "string",
          "enum": [
            "metadata-store"
          ]
        },
        {
          "description": "[IN DEVELOPMENT] Serves a log server for replicated loglets",
          "type": "string",
          "enum": [
            "log-server"
          ]
        }
      ]
    },
    "LogFormat": {
      "title": "Log format",
      "oneOf": [
        {
          "title": "Pretty",
          "description": "Enables verbose logging. Not recommended in production.",
          "type": "string",
          "enum": [
            "pretty"
          ]
        },
        {
          "title": "Compact",
          "description": "Enables compact logging.",
          "type": "string",
          "enum": [
            "compact"
          ]
        },
        {
          "title": "Json",
          "description": "Enables json logging. You can use a json log collector to ingest these logs and further process them.",
          "type": "string",
          "enum": [
            "json"
          ]
        }
      ]
    },
    "RocksbPerfStatisticsLevel": {
      "oneOf": [
        {
          "description": "Disable perf stats",
          "type": "string",
          "enum": [
            "disable"
          ]
        },
        {
          "description": "Enables only count stats",
          "type": "string",
          "enum": [
            "enable-count"
          ]
        },
        {
          "description": "Count stats and enable time stats except for mutexes",
          "type": "string",
          "enum": [
            "enable-time-except-for-mutex"
          ]
        },
        {
          "description": "Other than time, also measure CPU time counters. Still don't measure time (neither wall time nor CPU time) for mutexes",
          "type": "string",
          "enum": [
            "enable-time-and-c-p-u-time-except-for-mutex"
          ]
        },
        {
          "description": "Enables count and time stats",
          "type": "string",
          "enum": [
            "enable-time"
          ]
        }
      ]
    },
    "MetadataStoreClient": {
      "title": "Metadata Store",
      "description": "Definition of a bootstrap metadata store",
      "oneOf": [
        {
          "description": "Connects to an embedded metadata store that is run by nodes that run with the MetadataStore role.",
          "type": "object",
          "required": [
            "address",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "embedded"
              ]
            },
            "address": {
              "type": "string"
            }
          }
        },
        {
          "description": "Uses external etcd as metadata store. The addresses are formatted as `host:port`",
          "type": "object",
          "required": [
            "addresses",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "etcd"
              ]
            },
            "addresses": {
              "type": "string"
            }
          }
        }
      ]
    },
    "Http2KeepAliveOptions": {
      "title": "HTTP/2 Keep alive options",
      "description": "Configuration for the HTTP/2 keep-alive mechanism, using PING frames.\n\nPlease note: most gateways don't propagate the HTTP/2 keep-alive between downstream and upstream hosts. In those environments, you need to make sure the gateway can detect a broken connection to the upstream deployment(s).",
      "type": "object",
      "properties": {
        "interval": {
          "title": "HTTP/2 Keep-alive interval",
          "description": "Sets an interval for HTTP/2 PING frames should be sent to keep a connection alive.\n\nYou should set this timeout with a value lower than the `abort_timeout`.",
          "default": "40s",
          "type": "string"
        },
        "timeout": {
          "title": "Timeout",
          "description": "Sets a timeout for receiving an acknowledgement of the keep-alive ping.\n\nIf the ping is not acknowledged within the timeout, the connection will be closed.",
          "default": "20s",
          "type": "string"
        }
      }
    }
  }
}
