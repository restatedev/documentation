{
  "$schema": "https://json-schema.org/draft/2019-09/schema",
  "title": "Restate configuration file",
  "description": "Configuration for Restate server.",
  "type": "object",
  "required": [
    "tracing-filter"
  ],
  "properties": {
    "worker": {
      "default": {
        "cleanup-interval": "1h",
        "internal-queue-length": 1000,
        "invoker": {
          "abort-timeout": "1m",
          "concurrent-invocations-limit": 1000,
          "in-memory-queue-length-limit": 66049,
          "inactivity-timeout": "1m",
          "message-size-limit": null,
          "message-size-warning": "10.0 MiB",
          "retry-policy": {
            "factor": 2.0,
            "initial-interval": "50ms",
            "max-attempts": null,
            "max-interval": "10s",
            "type": "exponential"
          },
          "tmp-dir": null
        },
        "max-command-batch-size": 32,
        "num-timers-in-memory-limit": null,
        "snapshots": {
          "destination": null,
          "object-store-retry-policy": {
            "factor": 2.0,
            "initial-interval": "100ms",
            "max-attempts": 10,
            "max-interval": "10s",
            "type": "exponential"
          },
          "snapshot-interval-num-records": null
        },
        "storage": {
          "rocksdb-disable-wal": true,
          "rocksdb-log-keep-file-num": null,
          "rocksdb-log-level": null,
          "rocksdb-log-max-file-size": null,
          "rocksdb-memory-ratio": 0.49000000953674316
        }
      },
      "$ref": "#/definitions/WorkerOptions"
    },
    "admin": {
      "default": {
        "advertised-admin-endpoint": null,
        "bind-address": "0.0.0.0:9070",
        "concurrent-api-requests-limit": null,
        "disable-cluster-controller": false,
        "disable-web-ui": false,
        "experimental-feature-force-journal-retention": null,
        "heartbeat-interval": "1s 500ms",
        "log-trim-check-interval": "1h",
        "query-engine": {
          "memory-size": "4.0 GiB",
          "query-parallelism": null,
          "tmp-dir": null
        }
      },
      "$ref": "#/definitions/AdminOptions"
    },
    "ingress": {
      "default": {
        "advertised-ingress-endpoint": null,
        "bind-address": "0.0.0.0:8080",
        "concurrent-api-requests-limit": null,
        "kafka-clusters": []
      },
      "$ref": "#/definitions/IngressOptions"
    },
    "bifrost": {
      "default": {
        "append-retry-max-interval": "1s",
        "append-retry-min-interval": "10ms",
        "auto-recovery-interval": "15s",
        "default-provider": "replicated",
        "disable-auto-improvement": false,
        "local": {
          "rocksdb-disable-wal": false,
          "rocksdb-disable-wal-fsync": false,
          "rocksdb-log-keep-file-num": null,
          "rocksdb-log-level": null,
          "rocksdb-log-max-file-size": null,
          "rocksdb-memory-ratio": 0.5,
          "writer-batch-commit-count": 5000,
          "writer-batch-commit-duration": "0s"
        },
        "read-retry-policy": {
          "factor": 2.0,
          "initial-interval": "50ms",
          "max-attempts": 50,
          "max-interval": "1s",
          "type": "exponential"
        },
        "record-cache-memory-size": "250.0 MiB",
        "replicated-loglet": {
          "log-server-retry-policy": {
            "factor": 2.0,
            "initial-interval": "250ms",
            "max-attempts": 3,
            "max-interval": "2s",
            "type": "exponential"
          },
          "log-server-rpc-timeout": "2s",
          "maximum-inflight-records": 1000,
          "readahead-records": 100,
          "readahead-trigger-ratio": 0.5,
          "sequencer-inactivity-timeout": "15s",
          "sequencer-retry-policy": {
            "factor": 2.0,
            "initial-interval": "250ms",
            "max-attempts": null,
            "max-interval": "5s",
            "type": "exponential"
          }
        },
        "seal-retry-interval": "2s"
      },
      "$ref": "#/definitions/BifrostOptions"
    },
    "metadata-server": {
      "default": {
        "log-trim-threshold": 1000,
        "raft-election-tick": 10,
        "raft-heartbeat-tick": 2,
        "raft-tick-interval": "100ms",
        "request-queue-length": 32,
        "rocksdb-disable-wal": false,
        "rocksdb-log-keep-file-num": null,
        "rocksdb-log-level": null,
        "rocksdb-log-max-file-size": null,
        "rocksdb-memory-ratio": 0.009999999776482582,
        "status-update-interval": "5s"
      },
      "$ref": "#/definitions/MetadataServerOptions"
    },
    "networking": {
      "default": {
        "connect-retry-policy": {
          "factor": 2.0,
          "initial-interval": "250ms",
          "max-attempts": 10,
          "max-interval": "3s",
          "type": "exponential"
        },
        "connect-timeout": "3s",
        "data-stream-window-size": "2.0 MiB",
        "handshake-timeout": "3s",
        "http2-adaptive-window": true,
        "http2-keep-alive-interval": "1s",
        "http2-keep-alive-timeout": "3s"
      },
      "$ref": "#/definitions/NetworkingOptions"
    },
    "log-server": {
      "default": {
        "incoming-network-queue-length": 1000,
        "rocksdb-disable-wal": false,
        "rocksdb-disable-wal-fsync": false,
        "rocksdb-log-keep-file-num": null,
        "rocksdb-log-level": null,
        "rocksdb-log-max-file-size": null,
        "rocksdb-max-sub-compactions": 0,
        "rocksdb-memory-ratio": 0.5,
        "writer-batch-commit-count": 5000
      },
      "$ref": "#/definitions/LogServer"
    },
    "roles": {
      "description": "Defines the roles which this Restate node should run, by default the node starts with all roles.",
      "default": [
        "worker",
        "admin",
        "metadata-server",
        "log-server",
        "http-ingress"
      ],
      "type": "array",
      "items": {
        "$ref": "#/definitions/Role"
      },
      "uniqueItems": true
    },
    "node-name": {
      "title": "Node Name",
      "description": "Unique name for this node in the cluster. The node must not change unless it's started with empty local store. It defaults to the node's hostname.",
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "location": {
      "title": "Node Location",
      "description": "[PREVIEW FEATURE] Setting the location allows Restate to form a tree-like cluster topology. The value is written in the format of \"<region>[.zone]\" to assign this node to a specific region, or to a zone within a region.\n\nThe value of region and zone is arbitrary but whitespace and `.` are disallowed.\n\nNOTE: It's _strongly_ recommended to not change the node's location string after its initial registration. Changing the location may result in data loss or data inconsistency if `log-server` is enabled on this node.\n\nWhen this value is not set, the node is considered to be in the _default_ location. The _default_ location means that the node is not assigned to any specific region or zone.\n\n## Examples - `us-west` -- the node is in the `us-west` region. - `us-west.a1` -- the node is in the `us-west` region and in the `a1` zone. - `` -- [default] the node is in the default location",
      "type": "string"
    },
    "force-node-id": {
      "description": "If set, the node insists on acquiring this node ID.",
      "default": null,
      "type": [
        "integer",
        "null"
      ],
      "format": "uint32",
      "minimum": 0.0
    },
    "cluster-name": {
      "title": "Cluster name",
      "description": "A unique identifier for the cluster. All nodes in the same cluster should have the same.",
      "default": "localcluster",
      "type": "string"
    },
    "auto-provision": {
      "title": "Auto cluster provisioning",
      "description": "If true, then this node is allowed to automatically provision as a new cluster. This node *must* have an admin role and a new nodes configuration will be created that includes this node.\n\nauto-provision is allowed by default in development mode and is disabled if restate-server runs with `--production` flag to prevent cluster nodes from forming their own clusters, rather than forming a single cluster.\n\nUse `restatectl` to provision the cluster/node if automatic provisioning is disabled.\n\nThis can also be explicitly disabled by setting this value to false.\n\nDefault: true",
      "default": true,
      "type": "boolean"
    },
    "base-dir": {
      "description": "The working directory which this Restate node should use for relative paths. The default is `restate-data` under the current working directory.",
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "metadata-client": {
      "default": {
        "addresses": [
          "http://127.0.0.1:5122/"
        ],
        "backoff-policy": {
          "factor": 1.399999976158142,
          "initial-interval": "100ms",
          "max-attempts": 10,
          "max-interval": "1s",
          "type": "exponential"
        },
        "connect-timeout": "3s",
        "keep-alive-interval": "5s",
        "keep-alive-timeout": "5s",
        "type": "replicated"
      },
      "$ref": "#/definitions/MetadataClientOptions"
    },
    "bind-address": {
      "description": "Address to bind for the Node server. Derived from the advertised address, defaulting to `0.0.0.0:$PORT` (where the port will be inferred from the URL scheme).",
      "type": "string"
    },
    "advertised-address": {
      "description": "Address that other nodes will use to connect to this node. Default is `http://127.0.0.1:5122/`",
      "default": "http://127.0.0.1:5122/",
      "type": "string"
    },
    "default-num-partitions": {
      "title": "Partitions",
      "description": "Number of partitions that will be provisioned during initial cluster provisioning. partitions are the logical shards used to process messages.\n\nCannot be higher than `65535` (You should almost never need as many partitions anyway)\n\nNOTE 1: This config entry only impacts the initial number of partitions, the value of this entry is ignored for provisioned nodes/clusters.\n\nNOTE 2: This will be renamed to `default-num-partitions` by default as of v1.3+\n\nDefault: 24",
      "default": 24,
      "type": "integer",
      "format": "uint16",
      "minimum": 0.0
    },
    "default-replication": {
      "title": "Default replication factor",
      "description": "Configures the global default replication factor to be used by the the system.\n\nNote that this value only impacts the cluster initial provisioning and will not be respected after the cluster has been provisioned.\n\nTo update existing clusters use the `restatectl` utility.",
      "default": 1,
      "type": "string"
    },
    "shutdown-timeout": {
      "title": "Shutdown grace timeout",
      "description": "This timeout is used when shutting down the various Restate components to drain all the internal queues.\n\nCan be configured using the [`humantime`](https://docs.rs/humantime/latest/humantime/fn.parse_duration.html) format.",
      "default": "1m",
      "type": "string"
    },
    "default-thread-pool-size": {
      "title": "Default async runtime thread pool",
      "description": "Size of the default thread pool used to perform internal tasks. If not set, it defaults to the number of CPU cores.",
      "default": null,
      "type": [
        "integer",
        "null"
      ],
      "format": "uint",
      "minimum": 0.0
    },
    "log-filter": {
      "title": "Logging Filter",
      "description": "Log filter configuration. Can be overridden by the `RUST_LOG` environment variable. Check the [`RUST_LOG` documentation](https://docs.rs/tracing-subscriber/latest/tracing_subscriber/filter/struct.EnvFilter.html) for more details how to configure it.",
      "default": "warn,restate=info",
      "type": "string"
    },
    "log-format": {
      "title": "Logging format",
      "description": "Format to use when logging.",
      "default": "pretty",
      "$ref": "#/definitions/LogFormat"
    },
    "log-disable-ansi-codes": {
      "title": "Disable ANSI in log output",
      "description": "Disable ANSI terminal codes for logs. This is useful when the log collector doesn't support processing ANSI terminal codes.",
      "default": false,
      "type": "boolean"
    },
    "tokio-console-bind-address": {
      "description": "Address to bind for the tokio-console tracing subscriber. If unset and restate-server is built with tokio-console support, it'll listen on `0.0.0.0:6669`.",
      "type": "string"
    },
    "histogram-inactivity-timeout": {
      "description": "Timeout for idle histograms.\n\nThe duration after which a histogram is considered idle and will be removed from metric responses to save memory. This value should be configured higher than the scrape interval of the telemetry collection system (e.g. Prometheus).",
      "default": "3m",
      "type": [
        "string",
        "null"
      ]
    },
    "disable-prometheus": {
      "description": "Disable prometheus metric recording and reporting. Default is `false`.",
      "default": false,
      "type": "boolean"
    },
    "storage-high-priority-bg-threads": {
      "description": "Storage high priority thread pool\n\nThis configures the restate-managed storage thread pool for performing high-priority or latency-sensitive storage tasks when the IO operation cannot be performed on in-memory caches.",
      "type": [
        "integer",
        "null"
      ],
      "format": "uint",
      "minimum": 1.0
    },
    "storage-low-priority-bg-threads": {
      "description": "Storage low priority thread pool\n\nThis configures the restate-managed storage thread pool for performing low-priority or latency-insensitive storage tasks.",
      "type": [
        "integer",
        "null"
      ],
      "format": "uint",
      "minimum": 1.0
    },
    "rocksdb-total-memory-size": {
      "title": "Total memory limit for rocksdb caches and memtables.",
      "description": "This includes memory for uncompressed block cache and all memtables by all open databases. The memory size used for rocksdb caches.",
      "default": "6.0 GiB",
      "$ref": "#/definitions/NonZeroHumanBytes"
    },
    "rocksdb-total-memtables-ratio": {
      "title": "Rocksdb total memtable size ratio",
      "description": "The memory size used across all memtables (ratio between 0 to 1.0). This limits how much memory memtables can eat up from the value in rocksdb-total-memory-limit. When set to 0, memtables can take all available memory up to the value specified in rocksdb-total-memory-limit. This value will be sanitized to 1.0 if outside the valid bounds.",
      "default": 0.5,
      "type": "number",
      "format": "float"
    },
    "rocksdb-bg-threads": {
      "title": "Rocksdb Background Threads",
      "description": "The number of threads to reserve to Rocksdb background tasks. Defaults to the number of cores on the machine.",
      "type": [
        "integer",
        "null"
      ],
      "format": "uint32",
      "minimum": 1.0
    },
    "rocksdb-high-priority-bg-threads": {
      "title": "Rocksdb High Priority Background Threads",
      "description": "The number of threads to reserve to high priority Rocksdb background tasks.",
      "default": 2,
      "type": "integer",
      "format": "uint32",
      "minimum": 1.0
    },
    "rocksdb-write-stall-threshold": {
      "title": "Rocksdb stall detection threshold",
      "description": "This defines the duration after which a write is to be considered in \"stall\" state. For every write that meets this threshold, the system will increment the `restate.rocksdb_stall_flare` gauge, if the write is unstalled, the guage will be updated accordingly.",
      "default": "3s",
      "type": "string"
    },
    "rocksdb-enable-stall-on-memory-limit": {
      "title": "Allow rocksdb writes to stall if memory limit is reached",
      "description": "Note if automatic memory budgeting is enabled, it should be safe to allow rocksdb to stall if it hits the limit. However, if rocksdb stall kicked in, it's unlikely that the system will recover from this without intervention.",
      "default": false,
      "type": "boolean"
    },
    "rocksdb-perf-level": {
      "title": "Rocksdb performance statistics level",
      "description": "Defines the level of PerfContext used internally by rocksdb. Default is `enable-count` which should be sufficient for most users. Note that higher levels incur a CPU cost and might slow down the critical path.",
      "default": "enable-count",
      "$ref": "#/definitions/RocksbPerfStatisticsLevel"
    },
    "metadata-update-interval": {
      "title": "Metadata update interval",
      "description": "The idle time after which the node will check for metadata updates from metadata store. This helps the node detect if it has been operating with stale metadata for extended period of time, primarily because it didn't interact with other peers in the cluster during that period.",
      "default": "10s",
      "type": "string"
    },
    "metadata-fetch-from-peer-timeout": {
      "title": "Timeout for metadata peer-to-peer fetching",
      "description": "When a node detects that a new metadata version exists, it'll attempt to fetch it from its peers. After this timeout duration has passed, the node will attempt to fetch the metadata from metadata store as well. This is to ensure that the nodes converge quickly while reducing the load on the metadata store.",
      "default": "3s",
      "type": "string"
    },
    "network-error-retry-policy": {
      "title": "Network error retry policy",
      "description": "The retry policy for network related errors",
      "default": {
        "factor": 2.0,
        "initial-interval": "10ms",
        "max-attempts": 15,
        "max-interval": "5s",
        "type": "exponential"
      },
      "$ref": "#/definitions/RetryPolicy"
    },
    "initialization-timeout": {
      "title": "Initialization timeout",
      "description": "The timeout until the node gives up joining a cluster and initializing itself.",
      "default": "5m",
      "type": "string"
    },
    "disable-telemetry": {
      "title": "Disable telemetry",
      "description": "Restate uses Scarf to collect anonymous usage data to help us understand how the software is being used. You can set this flag to true to disable this collection. It can also be set with the environment variable DO_NOT_TRACK=1.",
      "default": false,
      "type": "boolean"
    },
    "tracing-endpoint": {
      "title": "Tracing Endpoint",
      "description": "This is a shortcut to set both [`Self::tracing_runtime_endpoint`], and [`Self::tracing_services_endpoint`].\n\nSpecify the tracing endpoint to send runtime traces to. Traces will be exported using [OTLP gRPC](https://opentelemetry.io/docs/specs/otlp/#otlpgrpc) through [opentelemetry_otlp](https://docs.rs/opentelemetry-otlp/0.12.0/opentelemetry_otlp/).\n\nTo configure the sampling, please refer to the [opentelemetry autoconfigure docs](https://github.com/open-telemetry/opentelemetry-java/blob/main/sdk-extensions/autoconfigure/README.md#sampler).",
      "type": [
        "string",
        "null"
      ]
    },
    "tracing-runtime-endpoint": {
      "title": "Runtime Tracing Endpoint",
      "description": "Overrides [`Self::tracing_endpoint`] for runtime traces\n\nSpecify the tracing endpoint to send runtime traces to. Traces will be exported using [OTLP gRPC](https://opentelemetry.io/docs/specs/otlp/#otlpgrpc) through [opentelemetry_otlp](https://docs.rs/opentelemetry-otlp/0.12.0/opentelemetry_otlp/).\n\nTo configure the sampling, please refer to the [opentelemetry autoconfigure docs](https://github.com/open-telemetry/opentelemetry-java/blob/main/sdk-extensions/autoconfigure/README.md#sampler).",
      "type": [
        "string",
        "null"
      ]
    },
    "tracing-services-endpoint": {
      "title": "Services Tracing Endpoint",
      "description": "Overrides [`Self::tracing_endpoint`] for services traces\n\nSpecify the tracing endpoint to send services traces to. Traces will be exported using [OTLP gRPC](https://opentelemetry.io/docs/specs/otlp/#otlpgrpc) through [opentelemetry_otlp](https://docs.rs/opentelemetry-otlp/0.12.0/opentelemetry_otlp/).\n\nTo configure the sampling, please refer to the [opentelemetry autoconfigure docs](https://github.com/open-telemetry/opentelemetry-java/blob/main/sdk-extensions/autoconfigure/README.md#sampler).",
      "type": [
        "string",
        "null"
      ]
    },
    "tracing-json-path": {
      "title": "Distributed Tracing JSON Export Path",
      "description": "If set, an exporter will be configured to write traces to files using the Jaeger JSON format. Each trace file will start with the `trace` prefix.\n\nIf unset, no traces will be written to file.\n\nIt can be used to export traces in a structured format without configuring a Jaeger agent.\n\nTo inspect the traces, open the Jaeger UI and use the Upload JSON feature to load and inspect them.",
      "type": [
        "string",
        "null"
      ]
    },
    "tracing-filter": {
      "title": "Tracing Filter",
      "description": "Distributed tracing exporter filter. Check the [`RUST_LOG` documentation](https://docs.rs/tracing-subscriber/latest/tracing_subscriber/filter/struct.EnvFilter.html) for more details how to configure it.",
      "type": "string"
    },
    "tracing-headers": {
      "title": "Additional tracing headers",
      "description": "Specify additional headers you want the system to send to the tracing endpoint (e.g. authentication headers).",
      "type": "object",
      "additionalProperties": {
        "type": "string"
      }
    },
    "request-identity-private-key-pem-file": {
      "title": "Request identity private key PEM file",
      "description": "A path to a file, such as \"/var/secrets/key.pem\", which contains exactly one ed25519 private key in PEM format. Such a file can be generated with `openssl genpkey -algorithm ed25519`. If provided, this key will be used to attach JWTs to requests from this client which SDKs may optionally verify, proving that the caller is a particular Restate instance.\n\nThis file is currently only read on client creation, but this may change in future. Parsed public keys will be logged at INFO level in the same format that SDKs expect.",
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "http-keep-alive-options": {
      "title": "HTTP/2 Keep-alive",
      "description": "Configuration for the HTTP/2 keep-alive mechanism, using PING frames. If unset, HTTP/2 keep-alive are disabled.",
      "default": {
        "interval": "40s",
        "timeout": "20s"
      },
      "$ref": "#/definitions/Http2KeepAliveOptions"
    },
    "http-proxy": {
      "title": "Proxy URI",
      "description": "A URI, such as `http://127.0.0.1:10001`, of a server to which all invocations should be sent, with the `Host` header set to the deployment URI. HTTPS proxy URIs are supported, but only HTTP endpoint traffic will be proxied currently. Can be overridden by the `HTTP_PROXY` environment variable.",
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "no-proxy": {
      "title": "No proxy",
      "description": "HTTP authorities eg `localhost`, `restate.dev`, `127.0.0.1` that should not be proxied by the http_proxy. Ports are ignored. Subdomains are also matched. An entry “*” matches all hostnames. Can be overridden by the `NO_PROXY` environment variable, which supports comma separated values.",
      "default": [],
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "connect-timeout": {
      "title": "Connect timeout",
      "description": "How long to wait for a TCP connection to be established before considering it a failed attempt.",
      "default": "10s",
      "type": "string"
    },
    "initial-max-send-streams": {
      "title": "Initial Max Send Streams",
      "description": "Sets the initial maximum of locally initiated (send) streams.\n\nThis value will be overwritten by the value included in the initial SETTINGS frame received from the peer as part of a [connection preface].\n\nDefault: None\n\n**NOTE**: Setting this value to None (default) users the default recommended value from HTTP2 specs",
      "default": null,
      "type": [
        "integer",
        "null"
      ],
      "format": "uint",
      "minimum": 0.0
    },
    "aws-profile": {
      "title": "AWS Profile",
      "description": "Name of the AWS profile to select. Defaults to 'AWS_PROFILE' env var, or otherwise the `default` profile.",
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "aws-assume-role-external-id": {
      "title": "AssumeRole external ID",
      "description": "An external ID to apply to any AssumeRole operations taken by this client. https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html Can be overridden by the `AWS_EXTERNAL_ID` environment variable.",
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "rocksdb-disable-direct-io-for-reads": {
      "title": "Disable Direct IO for reads",
      "description": "Files will be opened in \"direct I/O\" mode which means that data r/w from the disk will not be cached or buffered. The hardware buffer of the devices may however still be used. Memory mapped files are not impacted by these parameters.",
      "type": [
        "boolean",
        "null"
      ]
    },
    "rocksdb-disable-direct-io-for-flush-and-compactions": {
      "title": "Disable Direct IO for flush and compactions",
      "description": "Use O_DIRECT for writes in background flush and compactions.",
      "type": [
        "boolean",
        "null"
      ]
    },
    "rocksdb-disable-wal": {
      "title": "Disable WAL",
      "description": "The default depends on the different rocksdb use-cases at Restate.\n\nSupports hot-reloading (Partial / Bifrost only)",
      "type": [
        "boolean",
        "null"
      ]
    },
    "rocksdb-disable-statistics": {
      "description": "Disable rocksdb statistics collection\n\nDefault: False (statistics enabled)",
      "type": [
        "boolean",
        "null"
      ]
    },
    "rocksdb-max-background-jobs": {
      "title": "RocksDB max background jobs (flushes and compactions)",
      "description": "Default: the number of CPU cores on this node.",
      "type": [
        "integer",
        "null"
      ],
      "format": "uint32",
      "minimum": 1.0
    },
    "rocksdb-compaction-readahead-size": {
      "title": "RocksDB compaction readahead size in bytes",
      "description": "If non-zero, we perform bigger reads when doing compaction. If you're running RocksDB on spinning disks, you should set this to at least 2MB. That way RocksDB's compaction is doing sequential instead of random reads.",
      "anyOf": [
        {
          "$ref": "#/definitions/NonZeroHumanBytes"
        },
        {
          "type": "null"
        }
      ]
    },
    "rocksdb-statistics-level": {
      "title": "RocksDB statistics level",
      "description": "StatsLevel can be used to reduce statistics overhead by skipping certain types of stats in the stats collection process.\n\nDefault: \"except-detailed-timers\"",
      "anyOf": [
        {
          "$ref": "#/definitions/RocksbStatistics"
        },
        {
          "type": "null"
        }
      ]
    },
    "rocksdb-log-level": {
      "title": "RocksDB log level",
      "description": "Verbosity of the LOG.\n\nDefault: \"error\"",
      "default": null,
      "anyOf": [
        {
          "$ref": "#/definitions/RocksDbLogLevel"
        },
        {
          "type": "null"
        }
      ]
    },
    "rocksdb-log-keep-file-num": {
      "title": "RocksDB log keep file num",
      "description": "Number of info LOG files to keep\n\nDefault: 1",
      "default": null,
      "type": [
        "integer",
        "null"
      ],
      "format": "uint",
      "minimum": 0.0
    },
    "rocksdb-log-max-file-size": {
      "title": "RocksDB log max file size",
      "description": "Max size of info LOG file\n\nDefault: 64MB",
      "default": null,
      "anyOf": [
        {
          "$ref": "#/definitions/NonZeroHumanBytes"
        },
        {
          "type": "null"
        }
      ]
    },
    "rocksdb-block-size": {
      "title": "RocksDB block size",
      "description": "Uncompressed block size\n\nDefault: 64KiB",
      "anyOf": [
        {
          "$ref": "#/definitions/NonZeroHumanBytes"
        },
        {
          "type": "null"
        }
      ]
    },
    "gossip-tick-interval": {
      "title": "Gossip tick interval",
      "description": "The interval at which the failure detector will tick. Decrease this value for faster reaction to node failures. Note, that every tick comes with an overhead.",
      "default": "100ms",
      "type": "string"
    },
    "gossip-failure-threshold": {
      "title": "Gossip failure threshold",
      "description": "Specifies how many gossip intervals of inactivity need to pass before considering a node as dead.",
      "default": 10,
      "type": "integer",
      "format": "uint32",
      "minimum": 1.0
    },
    "gossip-num-peers": {
      "title": "Number of peers to gossip",
      "description": "On every gossip interval, how many peers each node attempts to gossip with. The default is optimized for small clusters (<5). On larger clusters, if gossip overhead is noticeable, consider reducing this value to 1.",
      "default": 2,
      "type": "integer",
      "format": "uint32",
      "minimum": 1.0
    },
    "gossip-fd-stability-threshold": {
      "title": "Gossips before failure detector is stable",
      "default": 3,
      "type": "integer",
      "format": "uint32",
      "minimum": 1.0
    },
    "gossip-suspect-interval": {
      "title": "Suspect duration",
      "description": "How long to keep a node in a transient state (suspect) before marking it as available. Larger values mean that the cluster is less prone to flaky nodes but extends the time it takes for a node to participate.\n\nA node becomes a suspect if it has been previously marked as dead for a given generation number. If the node incremented its generation number, it will not be impacted by this threshold.",
      "default": "5s",
      "type": "string"
    },
    "gossip-loneliness-threshold": {
      "title": "Gossip loneliness threshold",
      "description": "How many intervals need to pass without receiving any gossip messages before considering this node as potentially isolated/dead. This threshold is used in the case where the node can still send gossip messages but did not receive any. This can rarely happen in asymmetric network partitions.\n\nIn this case, the node will advertise itself as dead in the gossip messages it sends out.\n\nNote: this threshold does not apply to a cluster that's configured with a single node.",
      "default": 30,
      "type": "integer",
      "format": "uint32",
      "minimum": 1.0
    },
    "gossip-extras-exchange-frequency": {
      "title": "Gossip extras exchange frequency",
      "description": "In addition to basic health/liveness information, the gossip protocol is used to exchange extra information about the roles hosted by this node. For instance, which partitions are currently running, their configuration versions, and the durable LSN of the corresponding partition databases. This information is sent every Nth gossip message. This setting controls the frequency of this exchange. For instance, `10` means that every 10th gossip message will contain the extra information about.",
      "default": 10,
      "type": "integer",
      "format": "uint32",
      "minimum": 1.0
    },
    "gossip-time-skew-threshold": {
      "title": "Gossips time skew threshold",
      "description": "The time skew is the maximum acceptable time difference between the local node and the time reported by peers via gossip messages. The time skew is also used to ignore gossip messages that are too old.",
      "default": "1s",
      "type": "string"
    }
  },
  "definitions": {
    "WorkerOptions": {
      "title": "Worker options",
      "type": "object",
      "properties": {
        "internal-queue-length": {
          "title": "Internal queue for partition processor communication",
          "default": 1000,
          "type": "integer",
          "format": "uint",
          "minimum": 1.0
        },
        "num-timers-in-memory-limit": {
          "title": "Num timers in memory limit",
          "description": "The number of timers in memory limit is used to bound the amount of timers loaded in memory. If this limit is set, when exceeding it, the timers farther in the future will be spilled to disk.",
          "default": null,
          "type": [
            "integer",
            "null"
          ],
          "format": "uint",
          "minimum": 1.0
        },
        "cleanup-interval": {
          "title": "Cleanup interval",
          "description": "In order to clean up completed invocations, that is invocations invoked with an idempotency id, or workflows, Restate periodically scans among the completed invocations to check whether they need to be removed or not. This interval sets the scan interval of the cleanup procedure. Default: 1 hour.\n\nCan be configured using the [`humantime`](https://docs.rs/humantime/latest/humantime/fn.parse_duration.html) format.",
          "default": "1h",
          "type": "string"
        },
        "storage": {
          "default": {
            "rocksdb-disable-wal": true,
            "rocksdb-log-keep-file-num": null,
            "rocksdb-log-level": null,
            "rocksdb-log-max-file-size": null,
            "rocksdb-memory-ratio": 0.49000000953674316
          },
          "$ref": "#/definitions/StorageOptions"
        },
        "invoker": {
          "default": {
            "abort-timeout": "1m",
            "concurrent-invocations-limit": 1000,
            "in-memory-queue-length-limit": 66049,
            "inactivity-timeout": "1m",
            "message-size-limit": null,
            "message-size-warning": "10.0 MiB",
            "retry-policy": {
              "factor": 2.0,
              "initial-interval": "50ms",
              "max-attempts": null,
              "max-interval": "10s",
              "type": "exponential"
            },
            "tmp-dir": null
          },
          "$ref": "#/definitions/InvokerOptions"
        },
        "max-command-batch-size": {
          "title": "Maximum command batch size for partition processors",
          "description": "The maximum number of commands a partition processor will apply in a batch. The larger this value is, the higher the throughput and latency are.",
          "default": 32,
          "type": "integer",
          "format": "uint",
          "minimum": 1.0
        },
        "snapshots": {
          "title": "Snapshots",
          "description": "Snapshots provide a mechanism for safely trimming the log and efficient bootstrapping of new worker nodes.",
          "default": {
            "destination": null,
            "object-store-retry-policy": {
              "factor": 2.0,
              "initial-interval": "100ms",
              "max-attempts": 10,
              "max-interval": "10s",
              "type": "exponential"
            },
            "snapshot-interval-num-records": null
          },
          "$ref": "#/definitions/SnapshotsOptions"
        }
      }
    },
    "StorageOptions": {
      "title": "Storage options",
      "type": "object",
      "properties": {
        "num-partitions-to-share-memory-budget": {
          "description": "How many partitions to divide memory across?\n\nBy default this uses the value defined in `default-num-partitions` in the common section of the config.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint16",
          "minimum": 1.0
        },
        "rocksdb-memory-budget": {
          "description": "The memory budget for rocksdb memtables in bytes\n\nThe total is divided evenly across partitions. The divisor is defined in `num-partitions-to-share-memory-budget`. If this value is set, it overrides the ratio defined in `rocksdb-memory-ratio`.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonZeroHumanBytes"
            },
            {
              "type": "null"
            }
          ]
        },
        "rocksdb-memory-ratio": {
          "description": "The memory budget for rocksdb memtables as ratio\n\nThis defines the total memory for rocksdb as a ratio of all memory available to memtables (See `rocksdb-total-memtables-ratio` in common). The budget is then divided evenly across partitions. The divisor is defined in `num-partitions-to-share-memory-budget`",
          "default": 0.49000000953674316,
          "type": "number",
          "format": "float"
        },
        "persist-lsn-interval": {
          "title": "Persist LSN interval (deprecated)",
          "description": "This configuration option is deprecated and ignored in Restate >= 1.3.3.",
          "deprecated": true,
          "writeOnly": true,
          "type": [
            "string",
            "null"
          ]
        },
        "persist-lsn-threshold": {
          "title": "Persist LSN threshold (deprecated)",
          "description": "This configuration option is deprecated and ignored in Restate >= 1.3.3.",
          "deprecated": true,
          "writeOnly": true,
          "type": [
            "integer",
            "null"
          ],
          "format": "uint64",
          "minimum": 0.0
        },
        "rocksdb-disable-direct-io-for-reads": {
          "title": "Disable Direct IO for reads",
          "description": "Files will be opened in \"direct I/O\" mode which means that data r/w from the disk will not be cached or buffered. The hardware buffer of the devices may however still be used. Memory mapped files are not impacted by these parameters.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-disable-direct-io-for-flush-and-compactions": {
          "title": "Disable Direct IO for flush and compactions",
          "description": "Use O_DIRECT for writes in background flush and compactions.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-disable-wal": {
          "title": "Disable WAL",
          "description": "The default depends on the different rocksdb use-cases at Restate.\n\nSupports hot-reloading (Partial / Bifrost only)",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-disable-statistics": {
          "description": "Disable rocksdb statistics collection\n\nDefault: False (statistics enabled)",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-max-background-jobs": {
          "title": "RocksDB max background jobs (flushes and compactions)",
          "description": "Default: the number of CPU cores on this node.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 1.0
        },
        "rocksdb-compaction-readahead-size": {
          "title": "RocksDB compaction readahead size in bytes",
          "description": "If non-zero, we perform bigger reads when doing compaction. If you're running RocksDB on spinning disks, you should set this to at least 2MB. That way RocksDB's compaction is doing sequential instead of random reads.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonZeroHumanBytes"
            },
            {
              "type": "null"
            }
          ]
        },
        "rocksdb-statistics-level": {
          "title": "RocksDB statistics level",
          "description": "StatsLevel can be used to reduce statistics overhead by skipping certain types of stats in the stats collection process.\n\nDefault: \"except-detailed-timers\"",
          "anyOf": [
            {
              "$ref": "#/definitions/RocksbStatistics"
            },
            {
              "type": "null"
            }
          ]
        },
        "rocksdb-log-level": {
          "title": "RocksDB log level",
          "description": "Verbosity of the LOG.\n\nDefault: \"error\"",
          "default": null,
          "anyOf": [
            {
              "$ref": "#/definitions/RocksDbLogLevel"
            },
            {
              "type": "null"
            }
          ]
        },
        "rocksdb-log-keep-file-num": {
          "title": "RocksDB log keep file num",
          "description": "Number of info LOG files to keep\n\nDefault: 1",
          "default": null,
          "type": [
            "integer",
            "null"
          ],
          "format": "uint",
          "minimum": 0.0
        },
        "rocksdb-log-max-file-size": {
          "title": "RocksDB log max file size",
          "description": "Max size of info LOG file\n\nDefault: 64MB",
          "default": null,
          "anyOf": [
            {
              "$ref": "#/definitions/NonZeroHumanBytes"
            },
            {
              "type": "null"
            }
          ]
        },
        "rocksdb-block-size": {
          "title": "RocksDB block size",
          "description": "Uncompressed block size\n\nDefault: 64KiB",
          "anyOf": [
            {
              "$ref": "#/definitions/NonZeroHumanBytes"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "NonZeroHumanBytes": {
      "title": "Non-zero human-readable bytes",
      "description": "Non-zero human-readable bytes",
      "type": "string",
      "format": "non-zero human-bytes",
      "minimum": 1.0,
      "minLength": 1,
      "pattern": "^\\d+(\\.\\d+)? ?[KMG]B$"
    },
    "RocksbStatistics": {
      "oneOf": [
        {
          "description": "Disable all metrics",
          "type": "string",
          "enum": [
            "disable-all"
          ]
        },
        {
          "description": "Disable timer stats, and skip histogram stats",
          "type": "string",
          "enum": [
            "except-histogram-or-timers"
          ]
        },
        {
          "description": "Skip timer stats",
          "type": "string",
          "enum": [
            "except-timers"
          ]
        },
        {
          "description": "Collect all stats except time inside mutex lock AND time spent on compression.",
          "type": "string",
          "enum": [
            "except-detailed-timers"
          ]
        },
        {
          "description": "Collect all stats except the counters requiring to get time inside the mutex lock.",
          "type": "string",
          "enum": [
            "except-time-for-mutex"
          ]
        },
        {
          "description": "Collect all stats, including measuring duration of mutex operations. If getting time is expensive on the platform to run, it can reduce scalability to more threads, especially for writes.",
          "type": "string",
          "enum": [
            "all"
          ]
        }
      ]
    },
    "RocksDbLogLevel": {
      "description": "Verbosity of the LOG.",
      "type": "string",
      "enum": [
        "debug",
        "info",
        "warn",
        "error",
        "fatal",
        "header"
      ]
    },
    "InvokerOptions": {
      "title": "Invoker options",
      "type": "object",
      "properties": {
        "retry-policy": {
          "title": "Retry policy",
          "description": "Retry policy to use for all the invocations handled by this invoker.",
          "default": {
            "factor": 2.0,
            "initial-interval": "50ms",
            "max-attempts": null,
            "max-interval": "10s",
            "type": "exponential"
          },
          "$ref": "#/definitions/RetryPolicy"
        },
        "inactivity-timeout": {
          "title": "Inactivity timeout",
          "description": "This timer guards against stalled service/handler invocations. Once it expires, Restate triggers a graceful termination by asking the service invocation to suspend (which preserves intermediate progress).\n\nThe 'abort timeout' is used to abort the invocation, in case it doesn't react to the request to suspend.\n\nCan be configured using the [`humantime`](https://docs.rs/humantime/latest/humantime/fn.parse_duration.html) format.",
          "default": "1m",
          "type": "string"
        },
        "abort-timeout": {
          "title": "Abort timeout",
          "description": "This timer guards against stalled service/handler invocations that are supposed to terminate. The abort timeout is started after the 'inactivity timeout' has expired and the service/handler invocation has been asked to gracefully terminate. Once the timer expires, it will abort the service/handler invocation.\n\nThis timer potentially **interrupts** user code. If the user code needs longer to gracefully terminate, then this value needs to be set accordingly.\n\nCan be configured using the [`humantime`](https://docs.rs/humantime/latest/humantime/fn.parse_duration.html) format.",
          "default": "1m",
          "type": "string"
        },
        "message-size-warning": {
          "title": "Message size warning",
          "description": "Threshold to log a warning in case protocol messages coming from a service are larger than the specified amount.",
          "default": "10.0 MiB",
          "$ref": "#/definitions/NonZeroHumanBytes"
        },
        "message-size-limit": {
          "title": "Message size limit",
          "description": "Threshold to fail the invocation in case protocol messages coming from a service are larger than the specified amount.",
          "default": null,
          "anyOf": [
            {
              "$ref": "#/definitions/NonZeroHumanBytes"
            },
            {
              "type": "null"
            }
          ]
        },
        "tmp-dir": {
          "title": "Temporary directory",
          "description": "Temporary directory to use for the invoker temporary files. If empty, the system temporary directory will be used instead.",
          "default": null,
          "type": [
            "string",
            "null"
          ]
        },
        "in-memory-queue-length-limit": {
          "title": "Spill invocations to disk",
          "description": "Defines the threshold after which queues invocations will spill to disk at the path defined in `tmp-dir`. In other words, this is the number of invocations that can be kept in memory before spilling to disk. This is a per-partition limit.",
          "default": 66049,
          "type": "integer",
          "format": "uint",
          "minimum": 1.0
        },
        "concurrent-invocations-limit": {
          "title": "Limit number of concurrent invocations from this node",
          "description": "Number of concurrent invocations that can be processed by the invoker.",
          "default": 1000,
          "type": [
            "integer",
            "null"
          ],
          "format": "uint",
          "minimum": 1.0
        }
      }
    },
    "RetryPolicy": {
      "title": "Retry policy",
      "description": "Definition of a retry policy",
      "oneOf": [
        {
          "title": "None",
          "description": "No retry strategy.",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "none"
              ]
            }
          }
        },
        {
          "title": "Fixed delay",
          "description": "Retry with a fixed delay strategy.",
          "type": "object",
          "required": [
            "interval",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "fixed-delay"
              ]
            },
            "interval": {
              "title": "Interval",
              "description": "Interval between retries.\n\nCan be configured using the [`humantime`](https://docs.rs/humantime/latest/humantime/fn.parse_duration.html) format.",
              "type": "string"
            },
            "max_attempts": {
              "title": "Max attempts",
              "description": "Number of maximum attempts before giving up. Infinite retries if unset.",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint",
              "minimum": 1.0
            }
          }
        },
        {
          "title": "Exponential",
          "description": "Retry with an exponential strategy. The next retry is computed as `min(last_retry_interval * factor, max_interval)`.",
          "type": "object",
          "required": [
            "factor",
            "initial_interval",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "exponential"
              ]
            },
            "initial_interval": {
              "title": "Initial Interval",
              "description": "Initial interval for the first retry attempt.\n\nCan be configured using the [`humantime`](https://docs.rs/humantime/latest/humantime/fn.parse_duration.html) format.",
              "type": "string"
            },
            "factor": {
              "title": "Factor",
              "description": "The factor to use to compute the next retry attempt.",
              "type": "number",
              "format": "float"
            },
            "max_attempts": {
              "title": "Max attempts",
              "description": "Number of maximum attempts before giving up. Infinite retries if unset.",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint",
              "minimum": 1.0
            },
            "max_interval": {
              "title": "Max interval",
              "description": "Maximum interval between retries.",
              "type": [
                "string",
                "null"
              ]
            }
          }
        }
      ]
    },
    "SnapshotsOptions": {
      "title": "Snapshot options.",
      "description": "Partition store snapshotting settings. At a minimum, set `destination` and `snapshot-interval-num-records` to enable snapshotting. For a complete example, see [Snapshots](https://docs.restate.dev/operate/snapshots).",
      "type": "object",
      "properties": {
        "destination": {
          "title": "Snapshot destination URL",
          "description": "Base URL for cluster snapshots. Supports `s3://` and `file://` protocol scheme. S3-compatible object stores must support ETag-based conditional writes.\n\nDefault: `None`",
          "default": null,
          "type": [
            "string",
            "null"
          ]
        },
        "snapshot-interval-num-records": {
          "title": "Automatic snapshot creation frequency",
          "description": "Number of log records that trigger a snapshot to be created.\n\nAs snapshots are created asynchronously, the actual number of new records that will trigger a snapshot will vary. The counter for the subsequent snapshot begins from the LSN at which the previous snapshot export was initiated. Only leader Partition Processors will take snapshots for a given partition.\n\nThis setting does not influence explicitly requested snapshots triggered using `restatectl`.\n\nDefault: `None` - automatic snapshots are disabled",
          "default": null,
          "type": [
            "integer",
            "null"
          ],
          "format": "uint64",
          "minimum": 1.0
        },
        "object-store-retry-policy": {
          "title": "Error retry policy",
          "description": "A retry policy for dealing with retryable object store errors.",
          "default": {
            "factor": 2.0,
            "initial-interval": "100ms",
            "max-attempts": 10,
            "max-interval": "10s",
            "type": "exponential"
          },
          "$ref": "#/definitions/RetryPolicy"
        },
        "aws-profile": {
          "title": "AWS profile",
          "description": "The AWS configuration profile to use for S3 object store destinations. If you use named profiles in your AWS configuration, you can replace all the other settings with a single profile reference. See the [AWS documentation on profiles] (https://docs.aws.amazon.com/sdkref/latest/guide/file-format.html) for more.",
          "type": [
            "string",
            "null"
          ]
        },
        "aws-region": {
          "title": "AWS region",
          "description": "AWS region to use with S3 object store destinations. This may be inferred from the environment, for example the current region when running in EC2. Because of the request signing algorithm this must have a value. For Minio, you can generally set this to any string, such as `us-east-1`.",
          "type": [
            "string",
            "null"
          ]
        },
        "aws-access-key-id": {
          "title": "AWS access key",
          "description": "Username for Minio, or consult the service documentation for other S3-compatible stores.",
          "type": [
            "string",
            "null"
          ]
        },
        "aws-secret-access-key": {
          "title": "AWS secret key",
          "description": "Password for Minio, or consult the service documentation for other S3-compatible stores.",
          "type": [
            "string",
            "null"
          ]
        },
        "aws-session-token": {
          "title": "AWS session token",
          "description": "This is only needed with short-term STS session credentials.",
          "type": [
            "string",
            "null"
          ]
        },
        "aws-endpoint-url": {
          "title": "Object store API endpoint URL override",
          "description": "When you use Amazon S3, this is typically inferred from the region and there is no need to set it. With other object stores, you will have to provide an appropriate HTTP(S) endpoint. If *not* using HTTPS, also set `aws-allow-http` to `true`.",
          "type": [
            "string",
            "null"
          ]
        },
        "aws-allow-http": {
          "title": "Allow insecure HTTP",
          "description": "Allow plain HTTP to be used with the object store endpoint. Required when the endpoint URL that isn't using HTTPS.",
          "type": [
            "boolean",
            "null"
          ]
        }
      }
    },
    "AdminOptions": {
      "title": "Admin server options",
      "type": "object",
      "properties": {
        "bind-address": {
          "title": "Endpoint address",
          "description": "Address to bind for the Admin APIs.",
          "default": "0.0.0.0:9070",
          "type": "string"
        },
        "advertised-admin-endpoint": {
          "title": "Advertised Admin endpoint",
          "description": "Optional advertised Admin API endpoint.",
          "default": null,
          "type": "string",
          "format": "uri"
        },
        "concurrent-api-requests-limit": {
          "title": "Concurrency limit",
          "description": "Concurrency limit for the Admin APIs. Default is unlimited.",
          "default": null,
          "type": [
            "integer",
            "null"
          ],
          "format": "uint",
          "minimum": 1.0
        },
        "query-engine": {
          "default": {
            "memory-size": "4.0 GiB",
            "query-parallelism": null,
            "tmp-dir": null
          },
          "$ref": "#/definitions/QueryEngineOptions"
        },
        "heartbeat-interval": {
          "title": "Controller heartbeats",
          "description": "Controls the interval at which cluster controller polls nodes of the cluster.",
          "default": "1s 500ms",
          "type": "string"
        },
        "log-trim-check-interval": {
          "title": "Log trim check interval",
          "description": "Controls the interval at which cluster controller tries to trim the logs. Log trimming can be disabled by setting it to \"0s\".\n\nNote that this is only the interval at which logs are checked, and does not guarantee that trim will be performed. The conditions for safely trim the log vary depending on the deployment. For single nodes, the log records must be durably persisted to disk. In distributed deployments, automatic trimming requires an external snapshot destination - see `worker.snapshots` for more.",
          "default": "1h",
          "type": "string"
        },
        "disable-web-ui": {
          "description": "Disable serving the Restate Web UI on the admin port. Default is `false`.",
          "default": false,
          "type": "boolean"
        },
        "disable-cluster-controller": {
          "default": false,
          "type": "boolean"
        }
      }
    },
    "QueryEngineOptions": {
      "title": "Storage query engine options",
      "type": "object",
      "properties": {
        "memory-size": {
          "title": "Memory size limit",
          "description": "The total memory in bytes that can be used to preform sql queries",
          "default": "4.0 GiB",
          "$ref": "#/definitions/NonZeroHumanBytes"
        },
        "tmp-dir": {
          "title": "Temp folder to use for spill",
          "description": "The path to spill to",
          "default": null,
          "type": [
            "string",
            "null"
          ]
        },
        "query-parallelism": {
          "title": "Default query parallelism",
          "description": "The number of parallel partitions to use for a query execution",
          "default": null,
          "type": [
            "integer",
            "null"
          ],
          "format": "uint",
          "minimum": 1.0
        },
        "pgsql-bind-address": {
          "title": "Pgsql Bind address",
          "description": "The address to bind for the psql service.",
          "deprecated": true,
          "writeOnly": true,
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "IngressOptions": {
      "title": "Ingress options",
      "type": "object",
      "properties": {
        "bind-address": {
          "title": "Bind address",
          "description": "The address to bind for the ingress.",
          "default": "0.0.0.0:8080",
          "type": "string"
        },
        "concurrent-api-requests-limit": {
          "title": "Concurrency limit",
          "description": "Local concurrency limit to use to limit the amount of concurrent requests. If exceeded, the ingress will reply immediately with an appropriate status code. Default is unlimited.",
          "default": null,
          "type": [
            "integer",
            "null"
          ],
          "format": "uint",
          "minimum": 1.0
        },
        "kafka-clusters": {
          "default": [],
          "type": "array",
          "items": {
            "$ref": "#/definitions/KafkaClusterOptions"
          }
        },
        "advertised-ingress-endpoint": {
          "title": "Ingress endpoint",
          "description": "Ingress endpoint that the Web UI should use to interact with.",
          "default": null,
          "type": "string",
          "format": "uri"
        }
      }
    },
    "KafkaClusterOptions": {
      "title": "Kafka cluster options",
      "description": "Configuration options to connect to a Kafka cluster.",
      "type": "object",
      "required": [
        "brokers",
        "name"
      ],
      "properties": {
        "name": {
          "description": "Cluster name (Used to identify subscriptions).",
          "type": "string"
        },
        "brokers": {
          "title": "Servers",
          "description": "Initial list of brokers (host or host:port).",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "BifrostOptions": {
      "title": "Bifrost options",
      "type": "object",
      "properties": {
        "default-provider": {
          "title": "The default kind of loglet to be used",
          "description": "Default: Replicated",
          "default": "replicated",
          "$ref": "#/definitions/ProviderKind"
        },
        "local": {
          "description": "Configuration of local loglet provider",
          "default": {
            "rocksdb-disable-wal": false,
            "rocksdb-disable-wal-fsync": false,
            "rocksdb-log-keep-file-num": null,
            "rocksdb-log-level": null,
            "rocksdb-log-max-file-size": null,
            "rocksdb-memory-ratio": 0.5,
            "writer-batch-commit-count": 5000,
            "writer-batch-commit-duration": "0s"
          },
          "type": "string"
        },
        "replicated-loglet": {
          "description": "Configuration of replicated loglet provider",
          "default": {
            "log-server-retry-policy": {
              "factor": 2.0,
              "initial-interval": "250ms",
              "max-attempts": 3,
              "max-interval": "2s",
              "type": "exponential"
            },
            "log-server-rpc-timeout": "2s",
            "maximum-inflight-records": 1000,
            "readahead-records": 100,
            "readahead-trigger-ratio": 0.5,
            "sequencer-inactivity-timeout": "15s",
            "sequencer-retry-policy": {
              "factor": 2.0,
              "initial-interval": "250ms",
              "max-attempts": null,
              "max-interval": "5s",
              "type": "exponential"
            }
          },
          "$ref": "#/definitions/ReplicatedLoglet"
        },
        "read-retry-policy": {
          "title": "Read retry policy",
          "description": "Retry policy to use when bifrost waits for reconfiguration to complete during read operations",
          "default": {
            "factor": 2.0,
            "initial-interval": "50ms",
            "max-attempts": 50,
            "max-interval": "1s",
            "type": "exponential"
          },
          "$ref": "#/definitions/RetryPolicy"
        },
        "seal-retry-interval": {
          "title": "Seal retry interval",
          "description": "Interval to wait between retries of loglet seal failures",
          "default": "2s",
          "type": "string"
        },
        "auto-recovery-interval": {
          "title": "Auto recovery threshold",
          "description": "Time interval after which bifrost's auto-recovery mechanism will kick in. This is triggered in scenarios where the control plane took too long to complete loglet reconfigurations.",
          "default": "15s",
          "type": "string"
        },
        "append-retry-min-interval": {
          "title": "Append retry minimum interval",
          "description": "Minimum retry duration used by the exponential backoff mechanism for bifrost appends.",
          "default": "10ms",
          "type": "string"
        },
        "append-retry-max-interval": {
          "title": "Append retry maximum interval",
          "description": "Maximum retry duration used by the exponential backoff mechanism for bifrost appends.",
          "default": "1s",
          "type": "string"
        },
        "record-cache-memory-size": {
          "title": "In-memory RecordCache memory limit",
          "description": "Optional size of record cache in bytes. If set to 0, record cache will be disabled. Defaults: 250MB",
          "default": "250.0 MiB",
          "$ref": "#/definitions/HumanBytes"
        },
        "disable-auto-improvement": {
          "title": "Disable Automatic Improvement",
          "description": "When enabled, automatic improvement periodically checks with the loglet provider if the loglet configuration can be improved by performing a reconfiguration.\n\nThis allows the log to pick up replication property changes, apply better placement of replicas, or for other reasons.",
          "default": false,
          "type": "string"
        }
      }
    },
    "ProviderKind": {
      "description": "An enum with the list of supported loglet providers.",
      "oneOf": [
        {
          "description": "A local rocksdb-backed loglet.",
          "type": "string",
          "enum": [
            "local"
          ]
        },
        {
          "description": "Replicated loglets are restate's native log replication system. This requires `log-server` role to run on enough nodes in the cluster.",
          "type": "string",
          "enum": [
            "replicated"
          ]
        }
      ]
    },
    "ReplicatedLoglet": {
      "type": "object",
      "properties": {
        "maximum-inflight-records": {
          "description": "Maximum number of inflight records sequencer can accept\n\nOnce this maximum is hit, sequencer will induce back pressure on clients. This controls the total number of records regardless of how many batches.\n\nNote that this will be increased to fit the biggest batch of records being enqueued.",
          "default": 1000,
          "type": "integer",
          "format": "uint",
          "minimum": 1.0
        },
        "sequencer-retry-policy": {
          "description": "Sequencer retry policy\n\nBackoff introduced when sequencer fail to find a suitable spread of log servers",
          "default": {
            "factor": 2.0,
            "initial-interval": "250ms",
            "max-attempts": null,
            "max-interval": "5s",
            "type": "exponential"
          },
          "$ref": "#/definitions/RetryPolicy"
        },
        "sequencer-inactivity-timeout": {
          "description": "Sequencer inactivity timeout\n\nThe sequencer is allowed to consider itself quiescent if it did not commit records for this period of time. It may use this to sends pre-emptive release/seal check requests to log-servers.\n\nThe sequencer is also allowed to use this value as interval to send seal/release checks even if it's not quiescent.",
          "default": "15s",
          "type": "string"
        },
        "log-server-rpc-timeout": {
          "description": "Log Server RPC timeout\n\nTimeout waiting on log server response",
          "default": "2s",
          "type": "string"
        },
        "log-server-retry-policy": {
          "description": "Log Server RPC retry policy\n\nRetry policy for log server RPCs",
          "default": {
            "factor": 2.0,
            "initial-interval": "250ms",
            "max-attempts": 3,
            "max-interval": "2s",
            "type": "exponential"
          },
          "$ref": "#/definitions/RetryPolicy"
        },
        "readahead-records": {
          "description": "Maximum number of records to prefetch from log servers\n\nThe number of records bifrost will attempt to prefetch from replicated loglet's log-servers for every loglet reader (e.g. partition processor). Note that this mainly impacts readers that are not co-located with the loglet sequencer (i.e. partition processor followers).",
          "default": 100,
          "type": "integer",
          "format": "uint16",
          "minimum": 1.0
        },
        "readahead-trigger-ratio": {
          "description": "Trigger to prefetch more records\n\nWhen read-ahead is used (readahead-records), this value (percentage in float) will determine when readers should trigger a prefetch for another batch to fill up the buffer. For instance, if this value is 0.3, then bifrost will trigger a prefetch when 30% or more of the read-ahead slots become available (e.g. partition processor consumed records and freed up enough slots).\n\nThe higher the value is, the longer bifrost will wait before it triggers the next fetch, potentially fetching more records as a result.\n\nTo illustrate, if readahead-records is set to 100 and readahead-trigger-ratio is 1.0. Then bifrost will prefetch up to 100 records from log-servers and will not trigger the next prefetch unless the consumer consumes 100% of this buffer. This means that bifrost will read in batches but will not do while the consumer is still reading the previous batch.\n\nValue must be between 0 and 1. It will be clamped at `1.0`.",
          "default": 0.5,
          "type": "number",
          "format": "float"
        }
      }
    },
    "HumanBytes": {
      "title": "Human-readable bytes",
      "description": "Human-readable bytes",
      "type": "string",
      "format": "human-bytes",
      "minimum": 1.0,
      "minLength": 1,
      "pattern": "^\\d+(\\.\\d+)? ?[KMG]B$"
    },
    "MetadataServerOptions": {
      "title": "Metadata store options",
      "type": "object",
      "properties": {
        "request-queue-length": {
          "description": "Limit number of in-flight requests\n\nNumber of in-flight metadata store requests.",
          "default": 32,
          "type": "integer",
          "format": "uint",
          "minimum": 1.0
        },
        "rocksdb-memory-budget": {
          "description": "The memory budget for rocksdb memtables in bytes\n\nIf this value is set, it overrides the ratio defined in `rocksdb-memory-ratio`.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonZeroHumanBytes"
            },
            {
              "type": "null"
            }
          ]
        },
        "rocksdb-memory-ratio": {
          "description": "The memory budget for rocksdb memtables as ratio\n\nThis defines the total memory for rocksdb as a ratio of all memory available to memtables (See `rocksdb-total-memtables-ratio` in common).",
          "default": 0.009999999776482582,
          "type": "number",
          "format": "float"
        },
        "rocksdb-disable-direct-io-for-reads": {
          "title": "Disable Direct IO for reads",
          "description": "Files will be opened in \"direct I/O\" mode which means that data r/w from the disk will not be cached or buffered. The hardware buffer of the devices may however still be used. Memory mapped files are not impacted by these parameters.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-disable-direct-io-for-flush-and-compactions": {
          "title": "Disable Direct IO for flush and compactions",
          "description": "Use O_DIRECT for writes in background flush and compactions.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-disable-wal": {
          "title": "Disable WAL",
          "description": "The default depends on the different rocksdb use-cases at Restate.\n\nSupports hot-reloading (Partial / Bifrost only)",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-disable-statistics": {
          "description": "Disable rocksdb statistics collection\n\nDefault: False (statistics enabled)",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-max-background-jobs": {
          "title": "RocksDB max background jobs (flushes and compactions)",
          "description": "Default: the number of CPU cores on this node.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 1.0
        },
        "rocksdb-compaction-readahead-size": {
          "title": "RocksDB compaction readahead size in bytes",
          "description": "If non-zero, we perform bigger reads when doing compaction. If you're running RocksDB on spinning disks, you should set this to at least 2MB. That way RocksDB's compaction is doing sequential instead of random reads.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonZeroHumanBytes"
            },
            {
              "type": "null"
            }
          ]
        },
        "rocksdb-statistics-level": {
          "title": "RocksDB statistics level",
          "description": "StatsLevel can be used to reduce statistics overhead by skipping certain types of stats in the stats collection process.\n\nDefault: \"except-detailed-timers\"",
          "anyOf": [
            {
              "$ref": "#/definitions/RocksbStatistics"
            },
            {
              "type": "null"
            }
          ]
        },
        "rocksdb-log-level": {
          "title": "RocksDB log level",
          "description": "Verbosity of the LOG.\n\nDefault: \"error\"",
          "default": null,
          "anyOf": [
            {
              "$ref": "#/definitions/RocksDbLogLevel"
            },
            {
              "type": "null"
            }
          ]
        },
        "rocksdb-log-keep-file-num": {
          "title": "RocksDB log keep file num",
          "description": "Number of info LOG files to keep\n\nDefault: 1",
          "default": null,
          "type": [
            "integer",
            "null"
          ],
          "format": "uint",
          "minimum": 0.0
        },
        "rocksdb-log-max-file-size": {
          "title": "RocksDB log max file size",
          "description": "Max size of info LOG file\n\nDefault: 64MB",
          "default": null,
          "anyOf": [
            {
              "$ref": "#/definitions/NonZeroHumanBytes"
            },
            {
              "type": "null"
            }
          ]
        },
        "rocksdb-block-size": {
          "title": "RocksDB block size",
          "description": "Uncompressed block size\n\nDefault: 64KiB",
          "anyOf": [
            {
              "$ref": "#/definitions/NonZeroHumanBytes"
            },
            {
              "type": "null"
            }
          ]
        },
        "raft-election-tick": {
          "description": "The number of ticks before triggering an election\n\nThe number of ticks before triggering an election. The value must be larger than `raft_heartbeat_tick`. It's recommended to set `raft_election_tick = 10 * raft_heartbeat_tick`. Decrease this value if you want to react faster to failed leaders. Note, decreasing this value too much can lead to cluster instabilities due to falsely detecting dead leaders.",
          "default": 10,
          "type": "integer",
          "format": "uint",
          "minimum": 1.0
        },
        "raft-heartbeat-tick": {
          "description": "The number of ticks before sending a heartbeat\n\nA leader sends heartbeat messages to maintain its leadership every heartbeat ticks. Decrease this value to send heartbeats more often.",
          "default": 2,
          "type": "integer",
          "format": "uint",
          "minimum": 1.0
        },
        "raft-tick-interval": {
          "description": "The raft tick interval\n\nThe interval at which the raft node will tick. Decrease this value in order to let the Raft node react more quickly to changes. Note, that every tick comes with an overhead. Moreover, the tick interval directly affects the election timeout. If the election timeout becomes too small, then this can cause cluster instabilities due to frequent leader changes.",
          "default": "100ms",
          "type": "string"
        },
        "status-update-interval": {
          "description": "The status update interval\n\nThe interval at which the raft node will update its status. Decrease this value in order to see more recent status updates.",
          "default": "5s",
          "type": "string"
        },
        "log-trim-threshold": {
          "title": "The raft log trim threshold",
          "description": "The threshold for trimming the raft log. The log will be trimmed if the number of apply entries exceeds this threshold. The default value is `1000`.",
          "default": 1000,
          "type": [
            "integer",
            "null"
          ],
          "format": "uint64",
          "minimum": 0.0
        }
      }
    },
    "NetworkingOptions": {
      "title": "Networking options",
      "description": "Common network configuration options for communicating with Restate cluster nodes. Note that similar keys are present in other config sections, such as in Service Client options.",
      "type": "object",
      "properties": {
        "connect-timeout": {
          "title": "Connect timeout",
          "description": "TCP connection timeout for Restate cluster node-to-node network connections.",
          "default": "3s",
          "type": "string"
        },
        "connect-retry-policy": {
          "title": "Connect retry policy",
          "description": "Retry policy to use for internal node-to-node networking.",
          "default": {
            "factor": 2.0,
            "initial-interval": "250ms",
            "max-attempts": 10,
            "max-interval": "3s",
            "type": "exponential"
          },
          "$ref": "#/definitions/RetryPolicy"
        },
        "handshake-timeout": {
          "title": "Handshake timeout",
          "description": "Timeout for receiving a handshake response from Restate cluster peers.",
          "default": "3s",
          "type": "string"
        },
        "http2-keep-alive-interval": {
          "title": "HTTP/2 Keep Alive Interval",
          "default": "1s",
          "type": "string"
        },
        "http2-keep-alive-timeout": {
          "title": "HTTP/2 Keep Alive Timeout",
          "default": "3s",
          "type": "string"
        },
        "http2-adaptive-window": {
          "title": "HTTP/2 Adaptive Window",
          "default": true,
          "type": "boolean"
        },
        "data-stream-window-size": {
          "title": "Data Stream Window Size",
          "description": "Controls the number of bytes the can be sent on every data stream before inducing back pressure. Data streams are used for sending messages between nodes.\n\nThe value should is often derived from BDP (Bandwidth Delay Product) of the network. For instance, if the network has a bandwidth of 10 Gbps with a round-trip time of 5 ms, the BDP is 10 Gbps * 0.005 s = 6.25 MB. This means that the window size should be at least 6.25 MB to fully utilize the network bandwidth assuming the latency is constant. Our recommendation is to set the window size to 2x the BDP to account for any variations in latency.\n\nIf network latency is high, it's recommended to set this to a higher value. Maximum theoretical value is 2^31-1 (2 GiB - 1), but we will sanitize this value to 500 MiB.",
          "default": "2.0 MiB",
          "$ref": "#/definitions/NonZeroHumanBytes"
        }
      }
    },
    "LogServer": {
      "title": "Log server options",
      "description": "Configuration is only used on nodes running with `log-server` role.",
      "type": "object",
      "properties": {
        "rocksdb-memory-budget": {
          "description": "The memory budget for rocksdb memtables in bytes\n\nIf this value is set, it overrides the ratio defined in `rocksdb-memory-ratio`.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonZeroHumanBytes"
            },
            {
              "type": "null"
            }
          ]
        },
        "rocksdb-memory-ratio": {
          "description": "The memory budget for rocksdb memtables as ratio\n\nThis defines the total memory for rocksdb as a ratio of all memory available to the log-server.\n\n(See `rocksdb-total-memtables-ratio` in common).",
          "default": 0.5,
          "type": "number",
          "format": "float"
        },
        "rocksdb-disable-wal-fsync": {
          "description": "Disable fsync of WAL on every batch",
          "default": false,
          "type": "boolean"
        },
        "rocksdb-max-sub-compactions": {
          "description": "The maximum number of subcompactions to run in parallel.\n\nSetting this to 1 means no sub-compactions are allowed (i.e. only 1 thread will do the compaction).\n\nDefault is 0 which maps to floor(number of CPU cores / 2)",
          "default": 0,
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "rocksdb-max-wal-size": {
          "description": "The size limit of all WAL files\n\nUse this to limit the size of WAL files. If the size of all WAL files exceeds this limit, the oldest WAL file will be deleted and if needed, memtable flush will be triggered.\n\nNote: RocksDB internally counts the uncompressed bytes to determine the WAL size, and since the WAL is compressed, the actual size on disk will be significantly smaller than this value (~1/4 depending on the compression ratio). For instance, if this is set to \"1 MiB\", then rocksdb might decide to flush if the total WAL (on disk) reached ~260 KiB (compressed).\n\nDefault is `0` which translates into 6 times the memory allocated for membtables for this database.",
          "$ref": "#/definitions/HumanBytes"
        },
        "writer-batch-commit-count": {
          "description": "Trigger a commit when the batch size exceeds this threshold.\n\nSet to 0 or 1 to commit the write batch on every command.",
          "default": 5000,
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        },
        "incoming-network-queue-length": {
          "description": "The number of messages that can queue up on input network stream while request processor is busy.",
          "default": 1000,
          "type": "integer",
          "format": "uint",
          "minimum": 1.0
        },
        "rocksdb-disable-direct-io-for-reads": {
          "title": "Disable Direct IO for reads",
          "description": "Files will be opened in \"direct I/O\" mode which means that data r/w from the disk will not be cached or buffered. The hardware buffer of the devices may however still be used. Memory mapped files are not impacted by these parameters.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-disable-direct-io-for-flush-and-compactions": {
          "title": "Disable Direct IO for flush and compactions",
          "description": "Use O_DIRECT for writes in background flush and compactions.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-disable-wal": {
          "title": "Disable WAL",
          "description": "The default depends on the different rocksdb use-cases at Restate.\n\nSupports hot-reloading (Partial / Bifrost only)",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-disable-statistics": {
          "description": "Disable rocksdb statistics collection\n\nDefault: False (statistics enabled)",
          "type": [
            "boolean",
            "null"
          ]
        },
        "rocksdb-max-background-jobs": {
          "title": "RocksDB max background jobs (flushes and compactions)",
          "description": "Default: the number of CPU cores on this node.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 1.0
        },
        "rocksdb-compaction-readahead-size": {
          "title": "RocksDB compaction readahead size in bytes",
          "description": "If non-zero, we perform bigger reads when doing compaction. If you're running RocksDB on spinning disks, you should set this to at least 2MB. That way RocksDB's compaction is doing sequential instead of random reads.",
          "anyOf": [
            {
              "$ref": "#/definitions/NonZeroHumanBytes"
            },
            {
              "type": "null"
            }
          ]
        },
        "rocksdb-statistics-level": {
          "title": "RocksDB statistics level",
          "description": "StatsLevel can be used to reduce statistics overhead by skipping certain types of stats in the stats collection process.\n\nDefault: \"except-detailed-timers\"",
          "anyOf": [
            {
              "$ref": "#/definitions/RocksbStatistics"
            },
            {
              "type": "null"
            }
          ]
        },
        "rocksdb-log-level": {
          "title": "RocksDB log level",
          "description": "Verbosity of the LOG.\n\nDefault: \"error\"",
          "default": null,
          "anyOf": [
            {
              "$ref": "#/definitions/RocksDbLogLevel"
            },
            {
              "type": "null"
            }
          ]
        },
        "rocksdb-log-keep-file-num": {
          "title": "RocksDB log keep file num",
          "description": "Number of info LOG files to keep\n\nDefault: 1",
          "default": null,
          "type": [
            "integer",
            "null"
          ],
          "format": "uint",
          "minimum": 0.0
        },
        "rocksdb-log-max-file-size": {
          "title": "RocksDB log max file size",
          "description": "Max size of info LOG file\n\nDefault: 64MB",
          "default": null,
          "anyOf": [
            {
              "$ref": "#/definitions/NonZeroHumanBytes"
            },
            {
              "type": "null"
            }
          ]
        },
        "rocksdb-block-size": {
          "title": "RocksDB block size",
          "description": "Uncompressed block size\n\nDefault: 64KiB",
          "anyOf": [
            {
              "$ref": "#/definitions/NonZeroHumanBytes"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "Role": {
      "oneOf": [
        {
          "description": "A worker runs partition processor (journal, state, and drives invocations)",
          "type": "string",
          "enum": [
            "worker"
          ]
        },
        {
          "description": "Admin runs cluster controller and user-facing admin APIs",
          "type": "string",
          "enum": [
            "admin"
          ]
        },
        {
          "description": "Serves the metadata store",
          "type": "string",
          "enum": [
            "metadata-server"
          ]
        },
        {
          "description": "Serves a log-server for replicated loglets",
          "type": "string",
          "enum": [
            "log-server"
          ]
        },
        {
          "description": "Serves HTTP ingress requests",
          "type": "string",
          "enum": [
            "http-ingress"
          ]
        }
      ]
    },
    "MetadataClientOptions": {
      "title": "Metadata client options",
      "description": "The metadata client type to store metadata",
      "type": "object",
      "oneOf": [
        {
          "description": "Store metadata on the replicated metadata store that runs on nodes with the metadata-server role.",
          "type": "object",
          "required": [
            "addresses",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "replicated"
              ]
            },
            "addresses": {
              "title": "Restate metadata server address list",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        },
        {
          "description": "Store metadata on an external etcd cluster.\n\nThe addresses are formatted as `host:port`",
          "type": "object",
          "required": [
            "addresses",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "etcd"
              ]
            },
            "addresses": {
              "title": "Etcd cluster node address list",
              "type": "string"
            }
          }
        },
        {
          "description": "Store metadata on an external object store.",
          "type": "object",
          "required": [
            "path",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "object-store"
              ]
            },
            "path": {
              "title": "Object store path for metadata storage",
              "description": "This location will be used to persist cluster metadata. Takes the form of a URL with `s3://` as the protocol and bucket name as the authority, plus an optional prefix specified as the path component.\n\nExample: `s3://bucket/prefix`",
              "type": "string"
            },
            "object_store_retry_policy": {
              "title": "Error retry policy",
              "default": {
                "factor": 2.0,
                "initial-interval": "100ms",
                "max-attempts": 10,
                "max-interval": "10s",
                "type": "exponential"
              },
              "$ref": "#/definitions/RetryPolicy"
            },
            "aws-profile": {
              "title": "AWS profile",
              "description": "The AWS configuration profile to use for S3 object store destinations. If you use named profiles in your AWS configuration, you can replace all the other settings with a single profile reference. See the [AWS documentation on profiles] (https://docs.aws.amazon.com/sdkref/latest/guide/file-format.html) for more.",
              "type": [
                "string",
                "null"
              ]
            },
            "aws-region": {
              "title": "AWS region",
              "description": "AWS region to use with S3 object store destinations. This may be inferred from the environment, for example the current region when running in EC2. Because of the request signing algorithm this must have a value. For Minio, you can generally set this to any string, such as `us-east-1`.",
              "type": [
                "string",
                "null"
              ]
            },
            "aws-access-key-id": {
              "title": "AWS access key",
              "description": "Username for Minio, or consult the service documentation for other S3-compatible stores.",
              "type": [
                "string",
                "null"
              ]
            },
            "aws-secret-access-key": {
              "title": "AWS secret key",
              "description": "Password for Minio, or consult the service documentation for other S3-compatible stores.",
              "type": [
                "string",
                "null"
              ]
            },
            "aws-session-token": {
              "title": "AWS session token",
              "description": "This is only needed with short-term STS session credentials.",
              "type": [
                "string",
                "null"
              ]
            },
            "aws-endpoint-url": {
              "title": "Object store API endpoint URL override",
              "description": "When you use Amazon S3, this is typically inferred from the region and there is no need to set it. With other object stores, you will have to provide an appropriate HTTP(S) endpoint. If *not* using HTTPS, also set `aws-allow-http` to `true`.",
              "type": [
                "string",
                "null"
              ]
            },
            "aws-allow-http": {
              "title": "Allow insecure HTTP",
              "description": "Allow plain HTTP to be used with the object store endpoint. Required when the endpoint URL that isn't using HTTPS.",
              "type": [
                "boolean",
                "null"
              ]
            }
          }
        }
      ],
      "properties": {
        "connect-timeout": {
          "title": "Connect timeout",
          "description": "TCP connection timeout for connecting to the metadata store.",
          "default": "3s",
          "type": "string"
        },
        "keep-alive-interval": {
          "title": "Metadata Store Keep Alive Interval",
          "default": "5s",
          "type": "string"
        },
        "keep-alive-timeout": {
          "title": "Metadata Store Keep Alive Timeout",
          "default": "5s",
          "type": "string"
        },
        "backoff-policy": {
          "title": "Backoff policy used by the metadata client",
          "description": "Backoff policy used by the metadata client when it encounters concurrent modifications.",
          "default": {
            "factor": 1.399999976158142,
            "initial-interval": "100ms",
            "max-attempts": 10,
            "max-interval": "1s",
            "type": "exponential"
          },
          "$ref": "#/definitions/RetryPolicy"
        }
      }
    },
    "LogFormat": {
      "title": "Log format",
      "oneOf": [
        {
          "title": "Pretty",
          "description": "Enables verbose logging. Not recommended in production.",
          "type": "string",
          "enum": [
            "pretty"
          ]
        },
        {
          "title": "Compact",
          "description": "Enables compact logging.",
          "type": "string",
          "enum": [
            "compact"
          ]
        },
        {
          "title": "Json",
          "description": "Enables json logging. You can use a json log collector to ingest these logs and further process them.",
          "type": "string",
          "enum": [
            "json"
          ]
        }
      ]
    },
    "RocksbPerfStatisticsLevel": {
      "oneOf": [
        {
          "description": "Disable perf stats",
          "type": "string",
          "enum": [
            "disable"
          ]
        },
        {
          "description": "Enables only count stats",
          "type": "string",
          "enum": [
            "enable-count"
          ]
        },
        {
          "description": "Count stats and enable time stats except for mutexes",
          "type": "string",
          "enum": [
            "enable-time-except-for-mutex"
          ]
        },
        {
          "description": "Other than time, also measure CPU time counters. Still don't measure time (neither wall time nor CPU time) for mutexes",
          "type": "string",
          "enum": [
            "enable-time-and-c-p-u-time-except-for-mutex"
          ]
        },
        {
          "description": "Enables count and time stats",
          "type": "string",
          "enum": [
            "enable-time"
          ]
        }
      ]
    },
    "Http2KeepAliveOptions": {
      "title": "HTTP/2 Keep alive options",
      "description": "Configuration for the HTTP/2 keep-alive mechanism, using PING frames.\n\nPlease note: most gateways don't propagate the HTTP/2 keep-alive between downstream and upstream hosts. In those environments, you need to make sure the gateway can detect a broken connection to the upstream deployment(s).",
      "type": "object",
      "properties": {
        "interval": {
          "title": "HTTP/2 Keep-alive interval",
          "description": "Sets an interval for HTTP/2 PING frames should be sent to keep a connection alive.\n\nYou should set this timeout with a value lower than the `abort_timeout`.",
          "default": "40s",
          "type": "string"
        },
        "timeout": {
          "title": "Timeout",
          "description": "Sets a timeout for receiving an acknowledgement of the keep-alive ping.\n\nIf the ping is not acknowledged within the timeout, the connection will be closed.",
          "default": "20s",
          "type": "string"
        }
      }
    }
  }
}
